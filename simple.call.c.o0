
running 1 testsyk-jit-event: start-tracing
4
foo
yk-jit-event: stop-tracing
--- Begin aot ---
# IR format version: 0
# Num funcs: 19
# Num consts: 27
# Num global decls: 6
# Num types: 23
global_decl @shadowstack_0
global_decl @stderr
global_decl @.str
global_decl @.str.1
global_decl @.str.2
global_decl @.str.3

func foo(%arg0: i32) {
  bb0:
    %0_0: i32 = arg(0)
    call __yk_trace_basicblock_dummy(0i32, 0i32)
    %0_2: ptr = load @shadowstack_0
    %0_3: ptr = ptr_add %0_2, 4
    *@shadowstack_0 = %0_3
    %0_5: ptr = ptr_add %0_2, 0
    *%0_5 = %0_0
    # simplecall.c:19: void foo(int i) {
    br bb1
  bb1:
    # simplecall.c:20: if (i > 1) {
    call __yk_trace_basicblock_dummy(0i32, 1i32)
    %1_1: i32 = load %0_5
    %1_2: i1 = sgt %1_1, 1i32
    condbr %1_2, bb2, bb4 [safepoint: 2i64, (%0_2, %1_2)]
  bb2:
    # simplecall.c:21: fputs("foo\n", stderr);
    call __yk_trace_basicblock_dummy(0i32, 2i32)
    %2_1: ptr = load @stderr
    %2_2: i32 = call fputs(@.str, %2_1)
    # simplecall.c:22: } else {
    br bb3
  bb3:
    call __yk_trace_basicblock_dummy(0i32, 3i32)
    br bb6
  bb4:
    # simplecall.c:23: fputs("bar\n", stderr);
    call __yk_trace_basicblock_dummy(0i32, 4i32)
    %4_1: ptr = load @stderr
    %4_2: i32 = call fputs(@.str.1, %4_1)
    br bb5
  bb5:
    call __yk_trace_basicblock_dummy(0i32, 5i32)
    br bb6
  bb6:
    # simplecall.c:25: }
    call __yk_trace_basicblock_dummy(0i32, 6i32)
    br bb8
  bb7:
    call __yk_trace_basicblock_dummy(0i32, 7i32)
    *@shadowstack_0 = %0_2
    ret
  bb8:
    call __yk_trace_basicblock_dummy(0i32, 8i32)
    br bb7
}

func llvm.dbg.declare(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func fputs(%arg0: ptr, %arg1: ptr) -> i32;

func main(%arg0: i32, %arg1: ptr) -> i32 {
  bb0:
    %0_0: i32 = arg(0)
    %0_1: ptr = arg(1)
    call __yk_trace_basicblock_dummy(3i32, 0i32)
    %0_3: ptr = call malloc(1000000i64)
    %0_4: ptr = ptr_add %0_3, 24
    *@shadowstack_0 = %0_4
    %0_6: ptr = ptr_add %0_3, 0
    %0_7: ptr = ptr_add %0_3, 4
    %0_8: ptr = ptr_add %0_3, 8
    %0_9: ptr = alloca ptr, 1, 8
    %0_10: ptr = alloca {0: i64}, 1, 8
    %0_11: ptr = ptr_add %0_3, 16
    %0_12: ptr = ptr_add %0_3, 20
    *%0_6 = 0i32
    *%0_7 = %0_0
    # simplecall.c:27: int main(int argc, char **argv) {
    br bb1
  bb1:
    call __yk_trace_basicblock_dummy(3i32, 1i32)
    *%0_8 = %0_1
    # simplecall.c:28: YkMT *mt = yk_mt_new(NULL);
    %1_2: ptr = call yk_mt_new(0x0)
    br bb2
  bb2:
    call __yk_trace_basicblock_dummy(3i32, 2i32)
    *%0_9 = %1_2
    # simplecall.c:29: yk_mt_hot_threshold_set(mt, 0);
    %2_2: ptr = load %0_9
    call yk_mt_hot_threshold_set(%2_2, 0i32)
    # simplecall.c:30: YkLocation loc = yk_location_new();
    br bb3
  bb3:
    call __yk_trace_basicblock_dummy(3i32, 3i32)
    %3_1: i64 = call yk_location_new()
    br bb4
  bb4:
    call __yk_trace_basicblock_dummy(3i32, 4i32)
    %4_1: ptr = ptr_add %0_10, 0
    *%4_1 = %3_1
    # simplecall.c:32: int res = 9998;
    *%0_11 = 9998i32
    # simplecall.c:33: int i = 4;
    *%0_12 = 4i32
    # simplecall.c:34: NOOPT_VAL(loc);
    %4_5: i64 = load %0_10
    # simplecall.c:35: NOOPT_VAL(res);
    br bb5
  bb5:
    call __yk_trace_basicblock_dummy(3i32, 5i32)
    %5_1: i32 = load %0_11
    # simplecall.c:36: NOOPT_VAL(i);
    br bb6
  bb6:
    call __yk_trace_basicblock_dummy(3i32, 6i32)
    %6_1: i32 = load %0_12
    # simplecall.c:37: while (i > 0) {
    br bb7
  bb7:
    call __yk_trace_basicblock_dummy(3i32, 7i32)
    br bb8
  bb8:
    call __yk_trace_basicblock_dummy(3i32, 8i32)
    %8_1: i32 = load %0_12
    %8_2: i1 = sgt %8_1, 0i32
    condbr %8_2, bb9, bb13 [safepoint: 3i64, (%0_9, %0_10, %0_11, %0_12, %8_2)]
  bb9:
    # simplecall.c:38: yk_mt_control_point(mt, &loc);
    call __yk_trace_basicblock_dummy(3i32, 9i32)
    %9_1: ptr = load %0_9
    call llvm.experimental.patchpoint.void(0i64, 13i32, __ykrt_control_point, 3i32, %9_1, %0_10, 0i64, %0_9, %0_10, %0_11, %0_12) [safepoint: 0i64, (%0_9, %0_10, %0_11, %0_12)]
    # simplecall.c:39: fprintf(stderr, "%d\n", i);
    br bb10
  bb10:
    call __yk_trace_basicblock_dummy(3i32, 10i32)
    %10_1: ptr = load @stderr
    %10_2: i32 = load %0_12
    %10_3: i32 = call fprintf(%10_1, @.str.2, %10_2)
    # simplecall.c:40: foo(i);
    br bb11
  bb11:
    call __yk_trace_basicblock_dummy(3i32, 11i32)
    %11_1: i32 = load %0_12
    call foo(%11_1) [safepoint: 4i64, (%0_9, %0_10, %0_11, %0_12, %11_1)]
    # simplecall.c:41: res += 2;
    br bb12
  bb12:
    call __yk_trace_basicblock_dummy(3i32, 12i32)
    %12_1: i32 = load %0_11
    %12_2: i32 = add %12_1, 2i32
    *%0_11 = %12_2
    # simplecall.c:42: i--;
    %12_4: i32 = load %0_12
    %12_5: i32 = add %12_4, -1i32
    *%0_12 = %12_5
    # simplecall.c:37: while (i > 0) {
    br bb8
  bb13:
    # simplecall.c:44: fprintf(stderr, "%d\n", i);
    call __yk_trace_basicblock_dummy(3i32, 13i32)
    %13_1: ptr = load @stderr
    %13_2: i32 = load %0_12
    %13_3: i32 = call fprintf(%13_1, @.str.2, %13_2)
    # simplecall.c:45: fprintf(stderr, "exit\n");
    br bb14
  bb14:
    call __yk_trace_basicblock_dummy(3i32, 14i32)
    %14_1: ptr = load @stderr
    %14_2: i32 = call fprintf(%14_1, @.str.3)
    # simplecall.c:46: NOOPT_VAL(res);
    br bb15
  bb15:
    call __yk_trace_basicblock_dummy(3i32, 15i32)
    %15_1: i32 = load %0_11
    # simplecall.c:47: yk_location_drop(loc);
    br bb16
  bb16:
    call __yk_trace_basicblock_dummy(3i32, 16i32)
    %16_1: ptr = ptr_add %0_10, 0
    %16_2: i64 = load %16_1
    call yk_location_drop(%16_2)
    # simplecall.c:48: yk_mt_shutdown(mt);
    br bb17
  bb17:
    call __yk_trace_basicblock_dummy(3i32, 17i32)
    %17_1: ptr = load %0_9
    call yk_mt_shutdown(%17_1)
    # simplecall.c:49: return (EXIT_SUCCESS);
    br bb18
  bb18:
    call __yk_trace_basicblock_dummy(3i32, 18i32)
    br bb20
  bb19:
    call __yk_trace_basicblock_dummy(3i32, 19i32)
    ret 0i32
  bb20:
    call __yk_trace_basicblock_dummy(3i32, 20i32)
    br bb19
}

func yk_mt_new(%arg0: ptr) -> ptr;

func yk_mt_hot_threshold_set(%arg0: ptr, %arg1: i32);

func yk_location_new() -> i64;

func yk_mt_control_point(%arg0: ptr, %arg1: ptr);

func fprintf(%arg0: ptr, %arg1: ptr, ...) -> i32;

func yk_location_drop(%arg0: i64);

func yk_mt_shutdown(%arg0: ptr);

func __yk_unopt_foo(%arg0: i32) {
  bb0:
    %0_0: i32 = arg(0)
    call __yk_trace_basicblock(11i32, 0i32)
    %0_2: ptr = load @shadowstack_0
    %0_3: ptr = ptr_add %0_2, 4
    *@shadowstack_0 = %0_3
    %0_5: ptr = ptr_add %0_2, 0
    *%0_5 = %0_0
    # simplecall.c:19: void foo(int i) {
    br bb1
  bb1:
    # simplecall.c:20: if (i > 1) {
    call __yk_trace_basicblock(11i32, 1i32)
    %1_1: i32 = load %0_5
    %1_2: i1 = sgt %1_1, 1i32
    condbr %1_2, bb2, bb4 [safepoint: 5i64, (%0_2, %1_2)]
  bb2:
    # simplecall.c:21: fputs("foo\n", stderr);
    call __yk_trace_basicblock(11i32, 2i32)
    %2_1: ptr = load @stderr
    %2_2: i32 = call fputs(@.str, %2_1)
    # simplecall.c:22: } else {
    br bb3
  bb3:
    call __yk_trace_basicblock(11i32, 3i32)
    br bb6
  bb4:
    # simplecall.c:23: fputs("bar\n", stderr);
    call __yk_trace_basicblock(11i32, 4i32)
    %4_1: ptr = load @stderr
    %4_2: i32 = call fputs(@.str.1, %4_1)
    br bb5
  bb5:
    call __yk_trace_basicblock(11i32, 5i32)
    br bb6
  bb6:
    # simplecall.c:25: }
    call __yk_trace_basicblock(11i32, 6i32)
    br bb8
  bb7:
    call __yk_trace_basicblock(11i32, 7i32)
    *@shadowstack_0 = %0_2
    ret
  bb8:
    call __yk_trace_basicblock(11i32, 8i32)
    br bb7
}

func __yk_unopt_main(%arg0: i32, %arg1: ptr) -> i32 {
  bb0:
    %0_0: i32 = arg(0)
    %0_1: ptr = arg(1)
    call __yk_trace_basicblock(12i32, 0i32)
    %0_3: ptr = load @shadowstack_0
    %0_4: ptr = ptr_add %0_3, 0
    %0_5: ptr = ptr_add %0_3, 4
    %0_6: ptr = ptr_add %0_3, 8
    %0_7: ptr = alloca ptr, 1, 8
    %0_8: ptr = alloca {0: i64}, 1, 8
    %0_9: ptr = ptr_add %0_3, 16
    %0_10: ptr = ptr_add %0_3, 20
    *%0_4 = 0i32
    *%0_5 = %0_0
    # simplecall.c:27: int main(int argc, char **argv) {
    br bb1
  bb1:
    call __yk_trace_basicblock(12i32, 1i32)
    *%0_6 = %0_1
    # simplecall.c:28: YkMT *mt = yk_mt_new(NULL);
    %1_2: ptr = call yk_mt_new(0x0)
    br bb2
  bb2:
    call __yk_trace_basicblock(12i32, 2i32)
    *%0_7 = %1_2
    # simplecall.c:29: yk_mt_hot_threshold_set(mt, 0);
    %2_2: ptr = load %0_7
    call yk_mt_hot_threshold_set(%2_2, 0i32)
    # simplecall.c:30: YkLocation loc = yk_location_new();
    br bb3
  bb3:
    call __yk_trace_basicblock(12i32, 3i32)
    %3_1: i64 = call yk_location_new()
    br bb4
  bb4:
    call __yk_trace_basicblock(12i32, 4i32)
    %4_1: ptr = ptr_add %0_8, 0
    *%4_1 = %3_1
    # simplecall.c:32: int res = 9998;
    *%0_9 = 9998i32
    # simplecall.c:33: int i = 4;
    *%0_10 = 4i32
    # simplecall.c:34: NOOPT_VAL(loc);
    %4_5: i64 = load %0_8
    # simplecall.c:35: NOOPT_VAL(res);
    br bb5
  bb5:
    call __yk_trace_basicblock(12i32, 5i32)
    %5_1: i32 = load %0_9
    # simplecall.c:36: NOOPT_VAL(i);
    br bb6
  bb6:
    call __yk_trace_basicblock(12i32, 6i32)
    %6_1: i32 = load %0_10
    # simplecall.c:37: while (i > 0) {
    br bb7
  bb7:
    call __yk_trace_basicblock(12i32, 7i32)
    br bb8
  bb8:
    call __yk_trace_basicblock(12i32, 8i32)
    %8_1: i32 = load %0_10
    %8_2: i1 = sgt %8_1, 0i32
    condbr %8_2, bb9, bb13 [safepoint: 6i64, (%0_7, %0_8, %0_9, %0_10, %8_2)]
  bb9:
    # simplecall.c:38: yk_mt_control_point(mt, &loc);
    call __yk_trace_basicblock(12i32, 9i32)
    %9_1: ptr = load %0_7
    call llvm.experimental.patchpoint.void(1i64, 13i32, __ykrt_control_point, 3i32, %9_1, %0_8, 1i64, %0_7, %0_8, %0_9, %0_10) [safepoint: 1i64, (%0_7, %0_8, %0_9, %0_10)]
    # simplecall.c:39: fprintf(stderr, "%d\n", i);
    br bb10
  bb10:
    call __yk_trace_basicblock(12i32, 10i32)
    %10_1: ptr = load @stderr
    %10_2: i32 = load %0_10
    %10_3: i32 = call fprintf(%10_1, @.str.2, %10_2)
    # simplecall.c:40: foo(i);
    br bb11
  bb11:
    call __yk_trace_basicblock(12i32, 11i32)
    %11_1: i32 = load %0_10
    call __yk_unopt_foo(%11_1) [safepoint: 7i64, (%0_7, %0_8, %0_9, %0_10, %11_1)]
    # simplecall.c:41: res += 2;
    br bb12
  bb12:
    call __yk_trace_basicblock(12i32, 12i32)
    %12_1: i32 = load %0_9
    %12_2: i32 = add %12_1, 2i32
    *%0_9 = %12_2
    # simplecall.c:42: i--;
    %12_4: i32 = load %0_10
    %12_5: i32 = add %12_4, -1i32
    *%0_10 = %12_5
    # simplecall.c:37: while (i > 0) {
    br bb8
  bb13:
    # simplecall.c:44: fprintf(stderr, "%d\n", i);
    call __yk_trace_basicblock(12i32, 13i32)
    %13_1: ptr = load @stderr
    %13_2: i32 = load %0_10
    %13_3: i32 = call fprintf(%13_1, @.str.2, %13_2)
    # simplecall.c:45: fprintf(stderr, "exit\n");
    br bb14
  bb14:
    call __yk_trace_basicblock(12i32, 14i32)
    %14_1: ptr = load @stderr
    %14_2: i32 = call fprintf(%14_1, @.str.3)
    # simplecall.c:46: NOOPT_VAL(res);
    br bb15
  bb15:
    call __yk_trace_basicblock(12i32, 15i32)
    %15_1: i32 = load %0_9
    # simplecall.c:47: yk_location_drop(loc);
    br bb16
  bb16:
    call __yk_trace_basicblock(12i32, 16i32)
    %16_1: ptr = ptr_add %0_8, 0
    %16_2: i64 = load %16_1
    call yk_location_drop(%16_2)
    # simplecall.c:48: yk_mt_shutdown(mt);
    br bb17
  bb17:
    call __yk_trace_basicblock(12i32, 17i32)
    %17_1: ptr = load %0_7
    call yk_mt_shutdown(%17_1)
    # simplecall.c:49: return (EXIT_SUCCESS);
    br bb18
  bb18:
    call __yk_trace_basicblock(12i32, 18i32)
    br bb20
  bb19:
    call __yk_trace_basicblock(12i32, 19i32)
    ret 0i32
  bb20:
    call __yk_trace_basicblock(12i32, 20i32)
    br bb19
}

func malloc(%arg0: i64) -> ptr;

func __ykrt_control_point(%arg0: ptr, %arg1: ptr, %arg2: i64);

func llvm.experimental.patchpoint.void(%arg0: i64, %arg1: i32, %arg2: ptr, %arg3: i32, ...);

func llvm.experimental.stackmap(%arg0: i64, %arg1: i32, ...);

func __yk_trace_basicblock(%arg0: i32, %arg1: i32);

func __yk_trace_basicblock_dummy(%arg0: i32, %arg1: i32);

--- End aot ---
--- Begin jit-pre-opt ---
; compiled trace ID #0

func_decl fprintf (ptr, ptr, ...) -> i32
func_decl fputs (ptr, ptr) -> i32
global_decl @stderr
global_decl @.str.2
global_decl @shadowstack_0
global_decl @.str

entry:
    %0: ptr = param Direct(6, -56, 8)
    %1: ptr = param Direct(6, -48, 8)
    %2: ptr = param Register(15, 8, [])
    %3: ptr = param Register(12, 8, [])
    header_start [%0, %1, %2, %3]
    %5: ptr = lookup_global @stderr
    %6: ptr = load %5
    %7: i32 = load %3
    %8: ptr = lookup_global @.str.2
    %9: i32 = call @fprintf(%6, %8, %7)
    %10: i32 = load %3
    %11: ptr = lookup_global @shadowstack_0
    %12: ptr = load %11
    %13: ptr = ptr_add %12, 4
    %14: ptr = lookup_global @shadowstack_0
    *%14 = %13
    *%12 = %10
    %18: i32 = load %12
    %19: i1 = sgt %18, 1i32
    guard true, %19, [12:%0_7: %0, 12:%0_8: %1, 12:%0_9: %2, 12:%0_10: %3, 12:%11_1: %10, 11:%0_2: %12, 11:%1_2: 0i1] ; trace_gidx 0 safepoint_id 5
    %21: ptr = lookup_global @stderr
    %22: ptr = load %21
    %23: ptr = lookup_global @.str
    %24: i32 = call @fputs(%23, %22)
    %25: ptr = lookup_global @shadowstack_0
    *%25 = %12
    %27: i32 = load %2
    %28: i32 = add %27, 2i32
    *%2 = %28
    %30: i32 = load %3
    %31: i32 = add %30, 4294967295i32
    *%3 = %31
    %33: i32 = load %3
    %34: i1 = sgt %33, 0i32
    guard true, %34, [12:%0_7: %0, 12:%0_8: %1, 12:%0_9: %2, 12:%0_10: %3, 12:%8_2: 0i1] ; trace_gidx 1 safepoint_id 6
    %36: ptr = load %0
    header_end [%0, %1, %2, %3]
--- End jit-pre-opt ---
3
foo
yk-jit-event: enter-jit-code
2
foo
1
yk-jit-event: deoptimise
bar
0
exit

test lang_tests::simplecall.c ... [0m[32mok[0m

test result: [0m[32mok[0m. 1 passed; 0 failed; 0 ignored; 0 measured; 144 filtered out

[1m[32m     Running[0m langtest_ir_lowering.rs (target/debug/deps/ir_lowering_tests-c1b95c9cc09e6efe)
Running IR lowering tests...

running 0 tests

test result: [0m[32mok[0m. 0 passed; 0 failed; 0 ignored; 0 measured; 15 filtered out

[1m[32m     Running[0m unittests src/main.rs (target/debug/deps/xtask-4c08494a8574d087)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

[1m[32m     Running[0m unittests src/lib.rs (target/debug/deps/ykaddr-1d7626e857dabf69)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 7 filtered out; finished in 0.00s

[1m[32m     Running[0m unittests src/lib.rs (target/debug/deps/ykbuild-a4aa299b936ace8f)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

[1m[32m     Running[0m unittests src/lib.rs (target/debug/deps/ykcapi-cffc9183d590fc96)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

[1m[32m     Running[0m unittests src/lib.rs (target/debug/deps/ykrt-ae9361e075e1f2cb)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 236 filtered out; finished in 0.00s

[1m[32m     Running[0m unittests src/lib.rs (target/debug/deps/yksmp-6b12a6c992757043)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

Shared connection to bencher16.soft-dev.org closed.
