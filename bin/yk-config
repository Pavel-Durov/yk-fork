#!/bin/sh

set -e

# The parent directory of this script. Under some obscure circumstances $0 may
# not be accurate, so we do some quick and dirty sanity checking.
DIR=`dirname $0`
if [ ! -d "${DIR}/../ykrt" ]; then
    1>&2 echo "error: couldn't find parent directory of yk-config"
    exit 1
fi

# The AOT optimisations that we can tolerate.
#
# This is based on the O3 LTO pipeline defined in LLVM's
# `PassBuilder::buildLTODefaultPipeline()` in `PassBuilderPipelines.cpp`.
#
# We exlude any optimisations guarded by a "off-by-default" CLI flag.
#
# We omit anything to do with PGO, OpenMP, Bolt's inliner, vectorisation,
# control-flow integrity (CFI) or "remarks" for now. FIXME: think about which
# of those make sense to turn on for yk.
#
# FIXME; We also don't invoke any of the various callbacks in their pipeline,
# e.g. `invokePeepholeEPCallbacks()`. More investigation required.
#
# FIXME: In the C++ code that builds the default LTO pipeline, some passes have
# parameters and the passes can be run multiple times with differing parameters
# (e.g. `lowertypetests`). How do we express that here? Can we?
#
# Note that we don't intend yk to work like this in the long run. We hope to be
# able to give the user the standard choice clang command-line optimisation
# levels (O0, O1, ...). We are only working this way for now in order to
# understand which passes break yk.
#
# Passes always present in upstream's LTO pipeline (i.e. at >=O0):
AOTPASSES="annotation2metadata"
# Passes additionally present in upstream's O1 LTO pipeline.
AOTPASSES="${AOTPASSES},globaldce,forceattrs,inferattrs,callsite-splitting"
AOTPASSES="${AOTPASSES},ipsccp,called-value-propagation,function-attrs"
AOTPASSES="${AOTPASSES},rpo-function-attrs,globalsplit,wholeprogramdevirt"
# Passes additionally present in upstream's O2 LTO pipeline.
#
# FIXME: skipping some problematic passes for now:
#
# These cause test failures and need to be investigated. When adding these
# back, be sure to put them in the right place, and check if they should run
# more than once in the pipeline.
AOTPASSES="${AOTPASSES},globalopt"
#AOTPASSES="${AOTPASSES},mem2reg" -- breaks yk test suite.
AOTPASSES="${AOTPASSES},constmerge,instcombine"
# Note `aggressive-instcombine` is O3.
#
# FIXME: Also note that `inline` probably isn't doing anything since we require
# the interpreter to be built -O0, menaning clang will slap `noinline`
# everywhere.
AOTPASSES="${AOTPASSES},aggressive-instcombine,inline"
AOTPASSES="${AOTPASSES},globalopt,globaldce,argpromotion,deadargelim"
#AOTPASSES="${AOTPASSES},instcombine" -- this second invocation breaks yklua
#AOTPASSES="${AOTPASSES},jumpthreading,sroa,tailcallalim" -- break yk test suite.
AOTPASSES="${AOTPASSES},function-attrs"
#AOTPASSES="${AOTPASSES},licm,gvn" -- breaks yk test suite.
#AOTPASSES="${AOTPASSES},memcpyopt" -- breaks yklua
AOTPASSES="${AOTPASSES},dse,mldst-motion,loop-flatten,indvars"
AOTPASSES="${AOTPASSES},loop-deletion,loop-unroll,loop-distribute"
#AOTPASSES="${AOTPASSES},jumpthreading" -- breaks yklua
AOTPASSES="${AOTPASSES},lowertypetests,lowertypetests"
#AOTPASSES="${AOTPASSES},simplifycfg" -- breaks yk test suite.
AOTPASSES="${AOTPASSES},elim-avail-extern,globaldce"

OUTPUT=""

usage() {
    echo "Generate C compiler flags for building against the yk JIT.\n"
    echo "Usage:"
    echo "    yk-config <mode> <--cc|--cxx|--ar|--ranlib|--cppflags|--cflags|--ldflags>\n"
    echo "    Where <mode> is either 'debug' or 'release'."
}

handle_arg() {
    mode=$1
    shift

    if [ "x${YKB_YKLLVM_BIN_DIR}" != "x" ]; then
        ykllvm_bin_dir=`realpath ${YKB_YKLLVM_BIN_DIR}`
    else
        # The way this path is calculated must match that in ykbuild/build.rs.
        ykllvm_bin_dir=`realpath ${DIR}/../target/${mode}/ykllvm/bin/`
    fi

    case $1 in
        --cc) OUTPUT="${ykllvm_bin_dir}/clang" ;;
        --cxx) OUTPUT="${ykllvm_bin_dir}/clang++" ;;
        --ar) OUTPUT="${ykllvm_bin_dir}/llvm-ar" ;;
        --ranlib) OUTPUT="${ykllvm_bin_dir}/llvm-ranlib" ;;
        --cflags)
            # Enable LTO.
            OUTPUT="${OUTPUT} -flto"
            # Outline functions containing loops during AOT compilation. Needed
            # for `yk_unroll_safe`.
            OUTPUT="${OUTPUT} -fyk-noinline-funcs-with-loops"
            # Required so that our curated set of optimisation passes can run.
            # Without this, clang will slap `optnone` attributes on every
            # function, causing optimisations to skip them.
            OUTPUT="${OUTPUT} -Xclang -disable-O0-optnone"
            case $mode in
                debug) OUTPUT="$OUTPUT -g" ;;
            esac
            ;;
        --cppflags)
            # Path to yk.h
            OUTPUT="${OUTPUT} -I${DIR}/../ykcapi"
            ;;
        --ldflags)
            # Use lld.
            OUTPUT="${OUTPUT} -fuse-ld=lld"
            # Embed LLVM bitcode as late as possible.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--embed-bitcode-final"

            # Disable machine passes that would interfere with block mapping.
            #
            # If you are trying to figure out which pass is breaking the
            # mapping, you can add "-Wl,--mllvm=--print-before-all" and/or
            # "-Wl,--mllvm=--print-after-all" to see the MIR before/after
            # each pass. You can make the output smaller by filtering the
            # output by function name with
            # "-Wl,--mllvm=--filter-print-funcs=<func>". When you have found
            # the candidate, look in `TargetPassConfig.cpp` (in ykllvm) to
            # find the CLI switch required to disable the pass. If you can't
            # (or don't want to) eliminate a whole pass, then you can add
            # (or re-use) a yk-specific flag to disable only aspects of passes.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--disable-branch-fold"
            OUTPUT="${OUTPUT} -Wl,--mllvm=--disable-block-placement"
            # These next two passes interfere with the BlockDisambiguate pass.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--disable-early-taildup"
            OUTPUT="${OUTPUT} -Wl,--mllvm=--disable-tail-duplicate"
            # Interferes with the JIT's inlining stack.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-disable-tail-call-codegen"
            # Fallthrough optimisations distort block mapping.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-no-fallthrough"

            # Ensure control point is patched.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-patch-control-point"

            # Emit stackmaps used for JIT deoptimisation.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-insert-stackmaps"

            # Ensure we can unambiguously map back to LLVM IR blocks.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-block-disambiguate"

            # Use the yk extensions to the blockmap section.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-extended-llvmbbaddrmap-section"
            # Enable fix for spill reloads before stackmaps.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-stackmap-spillreloads-fix"
            # Enable shadow stacks.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-shadow-stack"
            # Encode additional locations in stackmaps.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-stackmap-add-locs"

            # Add known yk-friendly optimisations.
            #
            # This pairs with `-Xclang -disable-O0-optnone`. See above.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-optnone-after-ir-passes"
            OUTPUT="${OUTPUT} -Xlinker --lto-newpm-passes=${AOTPASSES}"

            # Have the `.llvmbc` and `.llvm_bb_addr_map` sections loaded into
            # memory by the loader.
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-alloc-llvmbc-section"
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-alloc-llvmbbaddrmap-section"

            # Emit a basic block map section. Used for block mapping.
            OUTPUT="${OUTPUT} -Wl,--lto-basic-block-sections=labels"

            # Ensure all symbols are exported so that the JIT can use them.
            # FIXME: https://github.com/ykjit/yk/issues/381
            # Find a better way of handling unexported globals inside a trace.
            OUTPUT="${OUTPUT} -Wl,--export-dynamic"
            OUTPUT="${OUTPUT} -Wl,--mllvm=--yk-linkage"

            # Linkage to yk as a library.
            OUTPUT="${OUTPUT} -L${DIR}/../target/${mode}/deps"

            # Encode an rpath so that we don't have to set LD_LIBRARY_PATH.
            #
            # FIXME: Adding rpaths should probably be behind a flag. It's kind
            # of rude to add local rpaths to interpreter binaries that
            # downstreams may want to distribute.
            OUTPUT="${OUTPUT} -Wl,-rpath=${DIR}/../target/${mode}/deps"
            OUTPUT="${OUTPUT} -Wl,-rpath=$(${ykllvm_bin_dir}/llvm-config --link-shared --libdir)"
            # Add a proper RPATH, not a RUNPATH:
            # https://bugs.launchpad.net/ubuntu/+source/glibc/+bug/1737608
            OUTPUT="${OUTPUT} -Wl,--disable-new-dtags"

            # Improve the quality of profiling data.
            OUTPUT="${OUTPUT} -Wl,--no-rosegment"
            ;;
        --libs)
            OUTPUT="${OUTPUT} -lykcapi"
            ;;
        *)
            1>&2 echo "unknown flag: $1\n"
            usage
            exit 1
            ;;
    esac
}

if [ $# -eq 0 ]; then
    usage
    exit 1
fi

case $1 in
    debug|release);;
    *) 1>&2 echo "unknown mode: $1\n"
       usage
       exit 1
       ;;
esac
mode=$1
shift

while [ $# -ne 0 ]; do
    handle_arg $mode $1
    shift
done

echo ${OUTPUT}
