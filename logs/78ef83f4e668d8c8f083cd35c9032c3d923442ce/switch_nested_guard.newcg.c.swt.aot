--- Begin aot ---
# IR format version: 0
# Num funcs: 16
# Num consts: 52
# Num global decls: 1
# Num types: 24
global_decl @shadowstack_0

func main(%arg0: i32, %arg1: ptr) -> i32 {
  bb0:
    %0_0: i32 = arg(0)
    %0_1: ptr = arg(1)
    call yk_trace_basicblock(0i32, 0i32)
    %0_3: ptr = alloca {0: ptr, 64: ptr, 128: ptr, 192: ptr, 256: ptr, 320: ptr, 384: ptr, 448: ptr}, 1, 8
    %0_4: ptr = call malloc(1000000i64)
    *@shadowstack_0 = %0_4
    %0_6: ptr = alloca ptr, 1, 8
    %0_7: ptr = alloca {0: i64}, 1, 8
    %0_8: ptr = ptr_add %0_4, 0
    %0_9: ptr = ptr_add %0_4, 4
    %0_10: ptr = ptr_add %0_4, 8
    %0_11: ptr = ptr_add %0_4, 12
    %0_12: ptr = ptr_add %0_4, 13
    br bb1
  bb1:
    # switch_nested_guard.newcg.c:17: YkMT *mt = yk_mt_new(NULL);
    call yk_trace_basicblock(0i32, 1i32)
    %1_1: ptr = call yk_mt_new(0x0)
    br bb2
  bb2:
    call yk_trace_basicblock(0i32, 2i32)
    *%0_6 = %1_1
    # switch_nested_guard.newcg.c:18: yk_mt_hot_threshold_set(mt, 3);
    call yk_mt_hot_threshold_set(%1_1, 3i32)
    # switch_nested_guard.newcg.c:19: YkLocation loc = yk_location_new();
    br bb3
  bb3:
    call yk_trace_basicblock(0i32, 3i32)
    %3_1: i64 = call yk_location_new()
    br bb4
  bb4:
    call yk_trace_basicblock(0i32, 4i32)
    *%0_7 = %3_1
    # switch_nested_guard.newcg.c:20: int i = 100;
    *%0_8 = 100i32
    # switch_nested_guard.newcg.c:21: int j = 0;
    *%0_9 = 0i32
    # switch_nested_guard.newcg.c:22: int k = 0;
    *%0_10 = 0i32
    # switch_nested_guard.newcg.c:24: NOOPT_VAL(j);
    br bb5
  bb5:
    call yk_trace_basicblock(0i32, 5i32)
    %5_1: i32 = load %0_9
    # switch_nested_guard.newcg.c:25: while (i > 0) {
    br bb6
  bb6:
    call yk_trace_basicblock(0i32, 6i32)
    br bb7
  bb7:
    call yk_trace_basicblock(0i32, 7i32)
    %7_1: i32 = load %0_8
    %7_2: i1 = sgt %7_1, 0i32
    condbr %7_2, bb8, bb26 [safepoint: 2i64, (%0_3, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %0_12, %7_2)]
  bb8:
    # switch_nested_guard.newcg.c:26: yk_mt_control_point(mt, &loc);
    call yk_trace_basicblock(0i32, 8i32)
    %8_1: ptr = load %0_6
    %8_2: ptr = ptr_add %0_3, 0
    *%8_2 = %0_6
    %8_4: ptr = ptr_add %0_3, 8
    *%8_4 = %0_7
    %8_6: ptr = ptr_add %0_3, 16
    *%8_6 = %0_8
    %8_8: ptr = ptr_add %0_3, 24
    *%8_8 = %0_9
    %8_10: ptr = ptr_add %0_3, 32
    *%8_10 = %0_10
    %8_12: ptr = ptr_add %0_3, 40
    *%8_12 = %0_11
    %8_14: ptr = ptr_add %0_3, 48
    *%8_14 = %0_12
    %8_16: ptr = ptr_add %0_3, 56
    *%8_16 = %8_1
    %8_18: ptr = call llvm.frameaddress.p0(0i32)
    call __ykrt_control_point(%8_1, %0_7, %0_3, %8_18, 3i64) [safepoint: 3i64, (%0_3, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %0_12, %8_1)]
    # switch_nested_guard.newcg.c:28: switch (j % 7) {
    br bb9
  bb9:
    call yk_trace_basicblock(0i32, 9i32)
    %9_1: i32 = load %0_9
    %9_2: i32 = srem %9_1, 7i32
    switch %9_2, bb24, [6 -> bb10, 5 -> bb18, 4 -> bb19, 3 -> bb20, 2 -> bb21, 1 -> bb22, 0 -> bb23] [safepoint: 0i64, (%0_3, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %0_12, %9_2)]
  bb10:
    # switch_nested_guard.newcg.c:30: switch (k % 5) {
    call yk_trace_basicblock(0i32, 10i32)
    %10_1: i32 = load %0_10
    %10_2: i32 = srem %10_1, 5i32
    switch %10_2, bb16, [4 -> bb11, 3 -> bb12, 2 -> bb13, 1 -> bb14, 0 -> bb15] [safepoint: 1i64, (%0_3, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %0_12, %10_2)]
  bb11:
    # switch_nested_guard.newcg.c:32: d = 'i';
    call yk_trace_basicblock(0i32, 11i32)
    *%0_12 = 105i8
    # switch_nested_guard.newcg.c:33: break;
    br bb16
  bb12:
    # switch_nested_guard.newcg.c:35: d = 'j';
    call yk_trace_basicblock(0i32, 12i32)
    *%0_12 = 106i8
    # switch_nested_guard.newcg.c:36: break;
    br bb16
  bb13:
    # switch_nested_guard.newcg.c:38: d = 'k';
    call yk_trace_basicblock(0i32, 13i32)
    *%0_12 = 107i8
    # switch_nested_guard.newcg.c:39: break;
    br bb16
  bb14:
    # switch_nested_guard.newcg.c:41: d = 'l';
    call yk_trace_basicblock(0i32, 14i32)
    *%0_12 = 108i8
    # switch_nested_guard.newcg.c:42: break;
    br bb16
  bb15:
    # switch_nested_guard.newcg.c:44: d = 'm';
    call yk_trace_basicblock(0i32, 15i32)
    *%0_12 = 109i8
    # switch_nested_guard.newcg.c:45: break;
    br bb16
  bb16:
    # switch_nested_guard.newcg.c:47: printf("%c", d);
    call yk_trace_basicblock(0i32, 16i32)
    %16_1: i8 = load %0_12
    %16_2: i32 = sext %16_1, i32
    %16_3: i32 = call putchar(%16_2)
    br bb17
  bb17:
    # switch_nested_guard.newcg.c:48: c = 'a';
    call yk_trace_basicblock(0i32, 17i32)
    *%0_11 = 97i8
    # switch_nested_guard.newcg.c:49: break;
    br bb24
  bb18:
    # switch_nested_guard.newcg.c:51: c = 'b';
    call yk_trace_basicblock(0i32, 18i32)
    *%0_11 = 98i8
    # switch_nested_guard.newcg.c:52: break;
    br bb24
  bb19:
    # switch_nested_guard.newcg.c:54: c = 'c';
    call yk_trace_basicblock(0i32, 19i32)
    *%0_11 = 99i8
    # switch_nested_guard.newcg.c:55: break;
    br bb24
  bb20:
    # switch_nested_guard.newcg.c:57: c = 'd';
    call yk_trace_basicblock(0i32, 20i32)
    *%0_11 = 100i8
    # switch_nested_guard.newcg.c:58: break;
    br bb24
  bb21:
    # switch_nested_guard.newcg.c:60: c = 'e';
    call yk_trace_basicblock(0i32, 21i32)
    *%0_11 = 101i8
    # switch_nested_guard.newcg.c:61: break;
    br bb24
  bb22:
    # switch_nested_guard.newcg.c:63: c = 'f';
    call yk_trace_basicblock(0i32, 22i32)
    *%0_11 = 102i8
    # switch_nested_guard.newcg.c:64: break;
    br bb24
  bb23:
    # switch_nested_guard.newcg.c:66: c = 'g';
    call yk_trace_basicblock(0i32, 23i32)
    *%0_11 = 103i8
    # switch_nested_guard.newcg.c:67: break;
    br bb24
  bb24:
    # switch_nested_guard.newcg.c:69: printf("%c", c);
    call yk_trace_basicblock(0i32, 24i32)
    %24_1: i8 = load %0_11
    %24_2: i32 = sext %24_1, i32
    %24_3: i32 = call putchar(%24_2)
    # switch_nested_guard.newcg.c:70: i--;
    br bb25
  bb25:
    call yk_trace_basicblock(0i32, 25i32)
    %25_1: i32 = load %0_8
    %25_2: i32 = add %25_1, -1i32
    *%0_8 = %25_2
    # switch_nested_guard.newcg.c:71: j++;
    %25_4: i32 = load %0_9
    %25_5: i32 = add %25_4, 1i32
    *%0_9 = %25_5
    # switch_nested_guard.newcg.c:72: k++;
    %25_7: i32 = load %0_10
    %25_8: i32 = add %25_7, 1i32
    *%0_10 = %25_8
    # switch_nested_guard.newcg.c:25: while (i > 0) {
    br bb7
  bb26:
    # switch_nested_guard.newcg.c:74: yk_location_drop(loc);
    call yk_trace_basicblock(0i32, 26i32)
    %26_1: i64 = load %0_7
    call yk_location_drop(%26_1)
    # switch_nested_guard.newcg.c:75: yk_mt_drop(mt);
    br bb27
  bb27:
    call yk_trace_basicblock(0i32, 27i32)
    %27_1: ptr = load %0_6
    call yk_mt_drop(%27_1)
    # switch_nested_guard.newcg.c:76: printf("\n");
    br bb28
  bb28:
    call yk_trace_basicblock(0i32, 28i32)
    %28_1: i32 = call putchar(10i32)
    # switch_nested_guard.newcg.c:78: return (EXIT_SUCCESS);
    br bb29
  bb29:
    call yk_trace_basicblock(0i32, 29i32)
    br bb31
  bb30:
    call yk_trace_basicblock(0i32, 30i32)
    ret 0i32
  bb31:
    call yk_trace_basicblock(0i32, 31i32)
    br bb30
}

func llvm.dbg.declare(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func yk_mt_new(%arg0: ptr) -> ptr;

func yk_mt_hot_threshold_set(%arg0: ptr, %arg1: i32);

func yk_location_new() -> i64;

func yk_mt_control_point(%arg0: ptr, %arg1: ptr);

func printf(%arg0: ptr, ...) -> i32;

func yk_location_drop(%arg0: i64);

func yk_mt_drop(%arg0: ptr);

func llvm.dbg.value(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func putchar(%arg0: i32) -> i32;

func malloc(%arg0: i64) -> ptr;

func __ykrt_control_point(%arg0: ptr, %arg1: ptr, %arg2: ptr, %arg3: ptr, %arg4: i64);

func llvm.frameaddress.p0(%arg0: i32) -> ptr;

func llvm.experimental.stackmap(%arg0: i64, %arg1: i32, ...);

func yk_trace_basicblock(%arg0: i32, %arg1: i32);

--- End aot ---
