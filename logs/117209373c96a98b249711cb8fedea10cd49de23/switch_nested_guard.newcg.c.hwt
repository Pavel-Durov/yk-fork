   Compiling ykrt v0.1.0 (/home/pd/git-repos/research/yk-fork/ykrt)
   Compiling ykcapi v0.1.0 (/home/pd/git-repos/research/yk-fork/ykcapi)
   Compiling tests v0.1.0 (/home/pd/git-repos/research/yk-fork/tests)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 6.70s
     Running unittests src/lib.rs (target/debug/deps/hwtracer-ee129e754ef3e6d5)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 15 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/tests-d06e60b0cfdb4b24)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/bin/dump_ir.rs (target/debug/deps/dump_ir-581c8afa999dd096)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/bin/gdb_c_test.rs (target/debug/deps/gdb_c_test-64e5bbe22ae313c1)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running langtest_c.rs (target/debug/deps/c_tests-afe3358ff41b9045)
Running C tests with opt level -O0...

running 1 testsyk-jit-event: start-tracing
yk-jit-event: stop-tracing
--- Begin aot ---
# IR format version: 0
# Num funcs: 15
# Num consts: 26
# Num global decls: 3
# Num types: 23
global_decl @shadowstack_0
global_decl @.str
global_decl @.str.1

func main(%arg0: i32, %arg1: ptr) -> i32 {
  bb0:
    %0_0: i32 = arg(0)
    %0_1: ptr = arg(1)
    %0_2: ptr = alloca {0: ptr, 64: ptr, 128: ptr, 192: ptr, 256: ptr, 320: ptr, 384: ptr, 448: ptr}, 1, 8
    %0_3: ptr = call malloc(1000000i64)
    *@shadowstack_0 = %0_3
    %0_5: ptr = alloca ptr, 1, 8
    %0_6: ptr = alloca {0: i64}, 1, 8
    %0_7: ptr = ptr_add %0_3, 0
    %0_8: ptr = ptr_add %0_3, 4
    %0_9: ptr = ptr_add %0_3, 8
    %0_10: ptr = ptr_add %0_3, 12
    %0_11: ptr = ptr_add %0_3, 13
    br bb1
  bb1:
    # switch_nested_guard.newcg.c:16: YkMT *mt = yk_mt_new(NULL);
    %1_0: ptr = call yk_mt_new(0x0)
    br bb2
  bb2:
    *%0_5 = %1_0
    # switch_nested_guard.newcg.c:17: yk_mt_hot_threshold_set(mt, 3);
    call yk_mt_hot_threshold_set(%1_0, 3i32)
    # switch_nested_guard.newcg.c:18: YkLocation loc = yk_location_new();
    br bb3
  bb3:
    %3_0: i64 = call yk_location_new()
    br bb4
  bb4:
    *%0_6 = %3_0
    # switch_nested_guard.newcg.c:22: int i = 12;
    *%0_7 = 12i32
    # switch_nested_guard.newcg.c:23: int j = 0;
    *%0_8 = 0i32
    # switch_nested_guard.newcg.c:24: int k = 0;
    *%0_9 = 0i32
    # switch_nested_guard.newcg.c:26: NOOPT_VAL(j);
    br bb5
  bb5:
    %5_0: i32 = load %0_8
    # switch_nested_guard.newcg.c:27: while (i > 0) {
    br bb6
  bb6:
    br bb7
  bb7:
    %7_0: i32 = load %0_7
    %7_1: i1 = sgt %7_0, 0i32
    condbr %7_1, bb8, bb26 [safepoint: 2i64, (%0_2, %0_5, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %7_1)]
  bb8:
    # switch_nested_guard.newcg.c:28: yk_mt_control_point(mt, &loc);
    %8_0: ptr = load %0_5
    %8_1: ptr = ptr_add %0_2, 0
    *%8_1 = %0_5
    %8_3: ptr = ptr_add %0_2, 8
    *%8_3 = %0_6
    %8_5: ptr = ptr_add %0_2, 16
    *%8_5 = %0_7
    %8_7: ptr = ptr_add %0_2, 24
    *%8_7 = %0_8
    %8_9: ptr = ptr_add %0_2, 32
    *%8_9 = %0_9
    %8_11: ptr = ptr_add %0_2, 40
    *%8_11 = %0_10
    %8_13: ptr = ptr_add %0_2, 48
    *%8_13 = %0_11
    %8_15: ptr = ptr_add %0_2, 56
    *%8_15 = %8_0
    %8_17: ptr = call llvm.frameaddress.p0(0i32)
    call __ykrt_control_point(%8_0, %0_6, %0_2, %8_17, 3i64) [safepoint: 3i64, (%0_2, %0_5, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %8_0)]
    # switch_nested_guard.newcg.c:30: switch (j % 7) {
    br bb9
  bb9:
    %9_0: i32 = load %0_8
    %9_1: i32 = srem %9_0, 7i32
    switch %9_1, bb24, [6 -> bb10, 5 -> bb18, 4 -> bb19, 3 -> bb20, 2 -> bb21, 1 -> bb22, 0 -> bb23] [safepoint: 0i64, (%0_2, %0_5, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %9_1)]
  bb10:
    # switch_nested_guard.newcg.c:32: switch (k % 5) {
    %10_0: i32 = load %0_9
    %10_1: i32 = srem %10_0, 5i32
    switch %10_1, bb16, [4 -> bb11, 3 -> bb12, 2 -> bb13, 1 -> bb14, 0 -> bb15] [safepoint: 1i64, (%0_2, %0_5, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %10_1)]
  bb11:
    # switch_nested_guard.newcg.c:34: d = 'i';
    *%0_11 = 105i8
    # switch_nested_guard.newcg.c:35: break;
    br bb16
  bb12:
    # switch_nested_guard.newcg.c:37: d = 'j';
    *%0_11 = 106i8
    # switch_nested_guard.newcg.c:38: break;
    br bb16
  bb13:
    # switch_nested_guard.newcg.c:40: d = 'k';
    *%0_11 = 107i8
    # switch_nested_guard.newcg.c:41: break;
    br bb16
  bb14:
    # switch_nested_guard.newcg.c:43: d = 'l';
    *%0_11 = 108i8
    # switch_nested_guard.newcg.c:44: break;
    br bb16
  bb15:
    # switch_nested_guard.newcg.c:46: d = 'm';
    *%0_11 = 109i8
    # switch_nested_guard.newcg.c:47: break;
    br bb16
  bb16:
    # switch_nested_guard.newcg.c:49: printf("1> %c\n", d);
    %16_0: i8 = load %0_11
    %16_1: i32 = sext %16_0, i32
    %16_2: i32 = call printf(@.str, %16_1)
    br bb17
  bb17:
    # switch_nested_guard.newcg.c:50: c = 'a';
    *%0_10 = 97i8
    # switch_nested_guard.newcg.c:51: break;
    br bb24
  bb18:
    # switch_nested_guard.newcg.c:53: c = 'b';
    *%0_10 = 98i8
    # switch_nested_guard.newcg.c:54: break;
    br bb24
  bb19:
    # switch_nested_guard.newcg.c:56: c = 'c';
    *%0_10 = 99i8
    # switch_nested_guard.newcg.c:57: break;
    br bb24
  bb20:
    # switch_nested_guard.newcg.c:59: c = 'd';
    *%0_10 = 100i8
    # switch_nested_guard.newcg.c:60: break;
    br bb24
  bb21:
    # switch_nested_guard.newcg.c:62: c = 'e';
    *%0_10 = 101i8
    # switch_nested_guard.newcg.c:63: break;
    br bb24
  bb22:
    # switch_nested_guard.newcg.c:65: c = 'f';
    *%0_10 = 102i8
    # switch_nested_guard.newcg.c:66: break;
    br bb24
  bb23:
    # switch_nested_guard.newcg.c:68: c = 'g';
    *%0_10 = 103i8
    # switch_nested_guard.newcg.c:69: break;
    br bb24
  bb24:
    # switch_nested_guard.newcg.c:71: printf("2> %c\n", c);
    %24_0: i8 = load %0_10
    %24_1: i32 = sext %24_0, i32
    %24_2: i32 = call printf(@.str.1, %24_1)
    # switch_nested_guard.newcg.c:72: i--;
    br bb25
  bb25:
    %25_0: i32 = load %0_7
    %25_1: i32 = add %25_0, -1i32
    *%0_7 = %25_1
    # switch_nested_guard.newcg.c:73: j++;
    %25_3: i32 = load %0_8
    %25_4: i32 = add %25_3, 1i32
    *%0_8 = %25_4
    # switch_nested_guard.newcg.c:74: k++;
    %25_6: i32 = load %0_9
    %25_7: i32 = add %25_6, 1i32
    *%0_9 = %25_7
    # switch_nested_guard.newcg.c:27: while (i > 0) {
    br bb7
  bb26:
    # switch_nested_guard.newcg.c:76: yk_location_drop(loc);
    %26_0: i64 = load %0_6
    call yk_location_drop(%26_0)
    # switch_nested_guard.newcg.c:77: yk_mt_drop(mt);
    br bb27
  bb27:
    %27_0: ptr = load %0_5
    call yk_mt_drop(%27_0)
    # switch_nested_guard.newcg.c:78: printf("\n");
    br bb28
  bb28:
    %28_0: i32 = call putchar(10i32)
    # switch_nested_guard.newcg.c:80: return (EXIT_SUCCESS);
    br bb29
  bb29:
    br bb31
  bb30:
    ret 0i32
  bb31:
    br bb30
}

func llvm.dbg.declare(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func yk_mt_new(%arg0: ptr) -> ptr;

func yk_mt_hot_threshold_set(%arg0: ptr, %arg1: i32);

func yk_location_new() -> i64;

func yk_mt_control_point(%arg0: ptr, %arg1: ptr);

func printf(%arg0: ptr, ...) -> i32;

func yk_location_drop(%arg0: i64);

func yk_mt_drop(%arg0: ptr);

func llvm.dbg.value(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func putchar(%arg0: i32) -> i32;

func malloc(%arg0: i64) -> ptr;

func __ykrt_control_point(%arg0: ptr, %arg1: ptr, %arg2: ptr, %arg3: ptr, %arg4: i64);

func llvm.frameaddress.p0(%arg0: i32) -> ptr;

func llvm.experimental.stackmap(%arg0: i64, %arg1: i32, ...);

--- End aot ---
bb9: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), tyidx: TyIdx(1), volatile: false }
bb9: BinaryOp { lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(9), iidx: InstIdx(0) }), binop: SRem, rhs: Const(ConstIdx(7)) }
bb9: Switch { test_val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(9), iidx: InstIdx(1) }), default_dest: BBlockIdx(24), case_values: [6, 5, 4, 3, 2, 1, 0], case_dests: [BBlockIdx(10), BBlockIdx(18), BBlockIdx(19), BBlockIdx(20), BBlockIdx(21), BBlockIdx(22), BBlockIdx(23)], safepoint: DeoptSafepoint { id: Const(ConstIdx(8)), lives: [LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(2) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(5) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(6) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(9) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(10) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(11) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(9), iidx: InstIdx(1) })] } }
bb20: Store { val: Const(ConstIdx(19)), tgt: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(10) }), volatile: false }
bb20: Br { succ: BBlockIdx(24) }
bb24: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(10) }), tyidx: TyIdx(7), volatile: false }
bb24: Cast { cast_kind: SExt, val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(24), iidx: InstIdx(0) }), dest_tyidx: TyIdx(1) }
bb24: Call { callee: FuncIdx(6), args: [Global(GlobalDeclIdx(2)), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(24), iidx: InstIdx(1) })], safepoint: None }
bb24: Br { succ: BBlockIdx(25) }
bb25: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), tyidx: TyIdx(1), volatile: false }
bb25: BinaryOp { lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(0) }), binop: Add, rhs: Const(ConstIdx(23)) }
bb25: Store { val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(1) }), tgt: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), volatile: false }
bb25: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), tyidx: TyIdx(1), volatile: false }
bb25: BinaryOp { lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(3) }), binop: Add, rhs: Const(ConstIdx(24)) }
bb25: Store { val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(4) }), tgt: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), volatile: false }
bb25: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(9) }), tyidx: TyIdx(1), volatile: false }
bb25: BinaryOp { lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(6) }), binop: Add, rhs: Const(ConstIdx(24)) }
bb25: Store { val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(7) }), tgt: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(9) }), volatile: false }
bb25: Br { succ: BBlockIdx(7) }
bb7: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), tyidx: TyIdx(1), volatile: false }
bb7: ICmp { tyidx: TyIdx(6), lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(7), iidx: InstIdx(0) }), pred: SignedGreater, rhs: Const(ConstIdx(4)) }
bb7: CondBr { cond: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(7), iidx: InstIdx(1) }), true_bb: BBlockIdx(8), false_bb: BBlockIdx(26), safepoint: DeoptSafepoint { id: Const(ConstIdx(5)), lives: [LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(2) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(5) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(6) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(9) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(10) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(11) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(7), iidx: InstIdx(1) })] } }
bb8: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(5) }), tyidx: TyIdx(2), volatile: false }
bb8: PtrAdd { tyidx: TyIdx(2), ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(2) }), const_off: 0, dyn_elem_counts: [], dyn_elem_sizes: [] }
yk-jit-event: enter-jit-code
yk-jit-event: deoptimise
yk-jit-event: enter-jit-code
yk-jit-event: deoptimise
yk-jit-event: enter-jit-code
yk-jit-event: deoptimise
yk-jit-event: enter-jit-code
yk-jit-event: deoptimise
yk-jit-event: enter-jit-code
yk-jit-event: deoptimise
yk-jit-event: start-side-tracing
yk-jit-event: stop-tracing
--- Begin aot ---
# IR format version: 0
# Num funcs: 15
# Num consts: 26
# Num global decls: 3
# Num types: 23
global_decl @shadowstack_0
global_decl @.str
global_decl @.str.1

func main(%arg0: i32, %arg1: ptr) -> i32 {
  bb0:
    %0_0: i32 = arg(0)
    %0_1: ptr = arg(1)
    %0_2: ptr = alloca {0: ptr, 64: ptr, 128: ptr, 192: ptr, 256: ptr, 320: ptr, 384: ptr, 448: ptr}, 1, 8
    %0_3: ptr = call malloc(1000000i64)
    *@shadowstack_0 = %0_3
    %0_5: ptr = alloca ptr, 1, 8
    %0_6: ptr = alloca {0: i64}, 1, 8
    %0_7: ptr = ptr_add %0_3, 0
    %0_8: ptr = ptr_add %0_3, 4
    %0_9: ptr = ptr_add %0_3, 8
    %0_10: ptr = ptr_add %0_3, 12
    %0_11: ptr = ptr_add %0_3, 13
    br bb1
  bb1:
    # switch_nested_guard.newcg.c:16: YkMT *mt = yk_mt_new(NULL);
    %1_0: ptr = call yk_mt_new(0x0)
    br bb2
  bb2:
    *%0_5 = %1_0
    # switch_nested_guard.newcg.c:17: yk_mt_hot_threshold_set(mt, 3);
    call yk_mt_hot_threshold_set(%1_0, 3i32)
    # switch_nested_guard.newcg.c:18: YkLocation loc = yk_location_new();
    br bb3
  bb3:
    %3_0: i64 = call yk_location_new()
    br bb4
  bb4:
    *%0_6 = %3_0
    # switch_nested_guard.newcg.c:22: int i = 12;
    *%0_7 = 12i32
    # switch_nested_guard.newcg.c:23: int j = 0;
    *%0_8 = 0i32
    # switch_nested_guard.newcg.c:24: int k = 0;
    *%0_9 = 0i32
    # switch_nested_guard.newcg.c:26: NOOPT_VAL(j);
    br bb5
  bb5:
    %5_0: i32 = load %0_8
    # switch_nested_guard.newcg.c:27: while (i > 0) {
    br bb6
  bb6:
    br bb7
  bb7:
    %7_0: i32 = load %0_7
    %7_1: i1 = sgt %7_0, 0i32
    condbr %7_1, bb8, bb26 [safepoint: 2i64, (%0_2, %0_5, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %7_1)]
  bb8:
    # switch_nested_guard.newcg.c:28: yk_mt_control_point(mt, &loc);
    %8_0: ptr = load %0_5
    %8_1: ptr = ptr_add %0_2, 0
    *%8_1 = %0_5
    %8_3: ptr = ptr_add %0_2, 8
    *%8_3 = %0_6
    %8_5: ptr = ptr_add %0_2, 16
    *%8_5 = %0_7
    %8_7: ptr = ptr_add %0_2, 24
    *%8_7 = %0_8
    %8_9: ptr = ptr_add %0_2, 32
    *%8_9 = %0_9
    %8_11: ptr = ptr_add %0_2, 40
    *%8_11 = %0_10
    %8_13: ptr = ptr_add %0_2, 48
    *%8_13 = %0_11
    %8_15: ptr = ptr_add %0_2, 56
    *%8_15 = %8_0
    %8_17: ptr = call llvm.frameaddress.p0(0i32)
    call __ykrt_control_point(%8_0, %0_6, %0_2, %8_17, 3i64) [safepoint: 3i64, (%0_2, %0_5, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %8_0)]
    # switch_nested_guard.newcg.c:30: switch (j % 7) {
    br bb9
  bb9:
    %9_0: i32 = load %0_8
    %9_1: i32 = srem %9_0, 7i32
    switch %9_1, bb24, [6 -> bb10, 5 -> bb18, 4 -> bb19, 3 -> bb20, 2 -> bb21, 1 -> bb22, 0 -> bb23] [safepoint: 0i64, (%0_2, %0_5, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %9_1)]
  bb10:
    # switch_nested_guard.newcg.c:32: switch (k % 5) {
    %10_0: i32 = load %0_9
    %10_1: i32 = srem %10_0, 5i32
    switch %10_1, bb16, [4 -> bb11, 3 -> bb12, 2 -> bb13, 1 -> bb14, 0 -> bb15] [safepoint: 1i64, (%0_2, %0_5, %0_6, %0_7, %0_8, %0_9, %0_10, %0_11, %10_1)]
  bb11:
    # switch_nested_guard.newcg.c:34: d = 'i';
    *%0_11 = 105i8
    # switch_nested_guard.newcg.c:35: break;
    br bb16
  bb12:
    # switch_nested_guard.newcg.c:37: d = 'j';
    *%0_11 = 106i8
    # switch_nested_guard.newcg.c:38: break;
    br bb16
  bb13:
    # switch_nested_guard.newcg.c:40: d = 'k';
    *%0_11 = 107i8
    # switch_nested_guard.newcg.c:41: break;
    br bb16
  bb14:
    # switch_nested_guard.newcg.c:43: d = 'l';
    *%0_11 = 108i8
    # switch_nested_guard.newcg.c:44: break;
    br bb16
  bb15:
    # switch_nested_guard.newcg.c:46: d = 'm';
    *%0_11 = 109i8
    # switch_nested_guard.newcg.c:47: break;
    br bb16
  bb16:
    # switch_nested_guard.newcg.c:49: printf("1> %c\n", d);
    %16_0: i8 = load %0_11
    %16_1: i32 = sext %16_0, i32
    %16_2: i32 = call printf(@.str, %16_1)
    br bb17
  bb17:
    # switch_nested_guard.newcg.c:50: c = 'a';
    *%0_10 = 97i8
    # switch_nested_guard.newcg.c:51: break;
    br bb24
  bb18:
    # switch_nested_guard.newcg.c:53: c = 'b';
    *%0_10 = 98i8
    # switch_nested_guard.newcg.c:54: break;
    br bb24
  bb19:
    # switch_nested_guard.newcg.c:56: c = 'c';
    *%0_10 = 99i8
    # switch_nested_guard.newcg.c:57: break;
    br bb24
  bb20:
    # switch_nested_guard.newcg.c:59: c = 'd';
    *%0_10 = 100i8
    # switch_nested_guard.newcg.c:60: break;
    br bb24
  bb21:
    # switch_nested_guard.newcg.c:62: c = 'e';
    *%0_10 = 101i8
    # switch_nested_guard.newcg.c:63: break;
    br bb24
  bb22:
    # switch_nested_guard.newcg.c:65: c = 'f';
    *%0_10 = 102i8
    # switch_nested_guard.newcg.c:66: break;
    br bb24
  bb23:
    # switch_nested_guard.newcg.c:68: c = 'g';
    *%0_10 = 103i8
    # switch_nested_guard.newcg.c:69: break;
    br bb24
  bb24:
    # switch_nested_guard.newcg.c:71: printf("2> %c\n", c);
    %24_0: i8 = load %0_10
    %24_1: i32 = sext %24_0, i32
    %24_2: i32 = call printf(@.str.1, %24_1)
    # switch_nested_guard.newcg.c:72: i--;
    br bb25
  bb25:
    %25_0: i32 = load %0_7
    %25_1: i32 = add %25_0, -1i32
    *%0_7 = %25_1
    # switch_nested_guard.newcg.c:73: j++;
    %25_3: i32 = load %0_8
    %25_4: i32 = add %25_3, 1i32
    *%0_8 = %25_4
    # switch_nested_guard.newcg.c:74: k++;
    %25_6: i32 = load %0_9
    %25_7: i32 = add %25_6, 1i32
    *%0_9 = %25_7
    # switch_nested_guard.newcg.c:27: while (i > 0) {
    br bb7
  bb26:
    # switch_nested_guard.newcg.c:76: yk_location_drop(loc);
    %26_0: i64 = load %0_6
    call yk_location_drop(%26_0)
    # switch_nested_guard.newcg.c:77: yk_mt_drop(mt);
    br bb27
  bb27:
    %27_0: ptr = load %0_5
    call yk_mt_drop(%27_0)
    # switch_nested_guard.newcg.c:78: printf("\n");
    br bb28
  bb28:
    %28_0: i32 = call putchar(10i32)
    # switch_nested_guard.newcg.c:80: return (EXIT_SUCCESS);
    br bb29
  bb29:
    br bb31
  bb30:
    ret 0i32
  bb31:
    br bb30
}

func llvm.dbg.declare(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func yk_mt_new(%arg0: ptr) -> ptr;

func yk_mt_hot_threshold_set(%arg0: ptr, %arg1: i32);

func yk_location_new() -> i64;

func yk_mt_control_point(%arg0: ptr, %arg1: ptr);

func printf(%arg0: ptr, ...) -> i32;

func yk_location_drop(%arg0: i64);

func yk_mt_drop(%arg0: ptr);

func llvm.dbg.value(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func putchar(%arg0: i32) -> i32;

func malloc(%arg0: i64) -> ptr;

func __ykrt_control_point(%arg0: ptr, %arg1: ptr, %arg2: ptr, %arg3: ptr, %arg4: i64);

func llvm.frameaddress.p0(%arg0: i32) -> ptr;

func llvm.experimental.stackmap(%arg0: i64, %arg1: i32, ...);

--- End aot ---
bb9: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), tyidx: TyIdx(1), volatile: false }
bb9: BinaryOp { lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(9), iidx: InstIdx(0) }), binop: SRem, rhs: Const(ConstIdx(7)) }
bb9: Switch { test_val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(9), iidx: InstIdx(1) }), default_dest: BBlockIdx(24), case_values: [6, 5, 4, 3, 2, 1, 0], case_dests: [BBlockIdx(10), BBlockIdx(18), BBlockIdx(19), BBlockIdx(20), BBlockIdx(21), BBlockIdx(22), BBlockIdx(23)], safepoint: DeoptSafepoint { id: Const(ConstIdx(8)), lives: [LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(2) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(5) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(6) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(9) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(10) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(11) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(9), iidx: InstIdx(1) })] } }
bb21: Store { val: Const(ConstIdx(20)), tgt: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(10) }), volatile: false }
bb21: Br { succ: BBlockIdx(24) }
bb24: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(10) }), tyidx: TyIdx(7), volatile: false }
bb24: Cast { cast_kind: SExt, val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(24), iidx: InstIdx(0) }), dest_tyidx: TyIdx(1) }
bb24: Call { callee: FuncIdx(6), args: [Global(GlobalDeclIdx(2)), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(24), iidx: InstIdx(1) })], safepoint: None }
bb24: Br { succ: BBlockIdx(25) }
bb25: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), tyidx: TyIdx(1), volatile: false }
bb25: BinaryOp { lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(0) }), binop: Add, rhs: Const(ConstIdx(23)) }
bb25: Store { val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(1) }), tgt: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), volatile: false }
bb25: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), tyidx: TyIdx(1), volatile: false }
bb25: BinaryOp { lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(3) }), binop: Add, rhs: Const(ConstIdx(24)) }
bb25: Store { val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(4) }), tgt: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), volatile: false }
bb25: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(9) }), tyidx: TyIdx(1), volatile: false }
bb25: BinaryOp { lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(6) }), binop: Add, rhs: Const(ConstIdx(24)) }
bb25: Store { val: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(25), iidx: InstIdx(7) }), tgt: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(9) }), volatile: false }
bb25: Br { succ: BBlockIdx(7) }
bb7: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), tyidx: TyIdx(1), volatile: false }
bb7: ICmp { tyidx: TyIdx(6), lhs: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(7), iidx: InstIdx(0) }), pred: SignedGreater, rhs: Const(ConstIdx(4)) }
bb7: CondBr { cond: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(7), iidx: InstIdx(1) }), true_bb: BBlockIdx(8), false_bb: BBlockIdx(26), safepoint: DeoptSafepoint { id: Const(ConstIdx(5)), lives: [LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(2) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(5) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(6) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(7) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(8) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(9) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(10) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(11) }), LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(7), iidx: InstIdx(1) })] } }
bb8: Load { ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(5) }), tyidx: TyIdx(2), volatile: false }
bb8: PtrAdd { tyidx: TyIdx(2), ptr: LocalVariable(InstID { funcidx: FuncIdx(0), bbidx: BBlockIdx(0), iidx: InstIdx(2) }), const_off: 0, dyn_elem_counts: [], dyn_elem_sizes: [] }
yk-jit-event: enter-jit-code
yk-jit-event: execute-side-trace
yk-jit-event: deoptimise
2> g
2> f
2> e
2> d
2> c
2> b
1> l
2> a
2> g
2> f
2> e
2> d
2> c


test lang_tests::switch_nested_guard.newcg.c ... [0m[32mok[0m

test result: [0m[32mok[0m. 1 passed; 0 failed; 0 ignored; 0 measured; 52 filtered out

     Running langtest_ir_lowering.rs (target/debug/deps/ir_lowering_tests-481f92c06ef8614e)
Running IR lowering tests...

running 0 tests

test result: [0m[32mok[0m. 0 passed; 0 failed; 0 ignored; 0 measured; 15 filtered out

     Running unittests src/main.rs (target/debug/deps/xtask-3c37d1ab81196a92)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/ykaddr-d1c6d3be7ce6d20d)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 7 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/ykbuild-ef866be891cd5609)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/ykcapi-ab49a43db501bbc8)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/ykrt-f26ff41f31919f07)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 130 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/yksmp-ddb4178b5982491b)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/lib.rs (target/debug/deps/yktracec-465a818b1aac4776)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

