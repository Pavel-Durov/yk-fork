running 1 testsyk-jit-event: start-tracing
4
foo
yk-jit-event: stop-tracing
--- Begin aot ---
# IR format version: 0
# Num funcs: 19
# Num consts: 38
# Num global decls: 6
# Num types: 24
global_decl @stderr
global_decl @.str
global_decl @.str.1
global_decl @shadowstack_0
global_decl @.str.2
global_decl @.str.3

func foo(%arg0: i32) {
  bb0:
    %0_0: i32 = arg(0)
    call __yk_trace_basicblock(0i32, 0i32)
    br bb1
  bb1:
    # simplecall.c:45: if (i > 1) {
    call __yk_trace_basicblock(0i32, 1i32)
    %1_1: i1 = sgt %0_0, 1i32
    %1_2: ptr = load @stderr
    %1_3: ptr = select %1_1, @.str, @.str.1
    %1_4: i64 = call fwrite(%1_3, 4i64, 1i64, %1_2)
    # simplecall.c:50: }
    br bb2
  bb2:
    call __yk_trace_basicblock(0i32, 2i32)
    br bb4
  bb3:
    call __yk_trace_basicblock(0i32, 3i32)
    ret
  bb4:
    call __yk_trace_basicblock(0i32, 4i32)
    br bb3
}

func llvm.dbg.value(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func fwrite(%arg0: ptr, %arg1: i64, %arg2: i64, %arg3: ptr) -> i64;

func main(%arg0: i32, %arg1: ptr) -> i32 {
  bb0:
    %0_0: i32 = arg(0)
    %0_1: ptr = arg(1)
    call __yk_trace_basicblock(3i32, 0i32)
    %0_3: ptr = call malloc(1000000i64)
    %0_4: ptr = ptr_add %0_3, 8
    *@shadowstack_0 = %0_4
    %0_6: ptr = alloca {0: i64}, 1, 8
    %0_7: ptr = ptr_add %0_3, 0
    %0_8: ptr = ptr_add %0_3, 4
    br bb1
  bb1:
    # simplecall.c:53: YkMT *mt = yk_mt_new(NULL);
    call __yk_trace_basicblock(3i32, 1i32)
    %1_1: ptr = call yk_mt_new(0x0)
    br bb2
  bb2:
    # simplecall.c:54: yk_mt_hot_threshold_set(mt, 0);
    call __yk_trace_basicblock(3i32, 2i32)
    call yk_mt_hot_threshold_set(%1_1, 0i32)
    # simplecall.c:55: YkLocation loc = yk_location_new();
    br bb3
  bb3:
    call __yk_trace_basicblock(3i32, 3i32)
    call llvm.lifetime.start.p0(8i64, %0_6)
    br bb4
  bb4:
    call __yk_trace_basicblock(3i32, 4i32)
    %4_1: i64 = call yk_location_new()
    br bb5
  bb5:
    call __yk_trace_basicblock(3i32, 5i32)
    *%0_6 = %4_1
    # simplecall.c:57: int res = 9998;
    call llvm.lifetime.start.p0(4i64, %0_7)
    br bb6
  bb6:
    call __yk_trace_basicblock(3i32, 6i32)
    *%0_7 = 9998i32
    # simplecall.c:58: int i = 4;
    call llvm.lifetime.start.p0(4i64, %0_8)
    br bb7
  bb7:
    call __yk_trace_basicblock(3i32, 7i32)
    *%0_8 = 4i32
    # simplecall.c:60: NOOPT_VAL(res);
    br bb8
  bb8:
    call __yk_trace_basicblock(3i32, 8i32)
    %8_1: i32 = load %0_7
    # simplecall.c:61: NOOPT_VAL(i);
    br bb9
  bb9:
    call __yk_trace_basicblock(3i32, 9i32)
    %9_1: i32 = load %0_8
    # simplecall.c:62: while (i > 0) {
    br bb10
  bb10:
    call __yk_trace_basicblock(3i32, 10i32)
    %10_1: i32 = load %0_8
    %10_2: i1 = sgt %10_1, 0i32
    condbr %10_2, bb11, bb17 [safepoint: 2i64, (%0_6, %0_7, %0_8, %1_1, %10_1, %10_2)]
  bb11:
    call __yk_trace_basicblock(3i32, 11i32)
    br bb12
  bb12:
    # simplecall.c:63: yk_mt_control_point(mt, &loc);
    call __yk_trace_basicblock(3i32, 12i32)
    call llvm.experimental.patchpoint.void(0i64, 13i32, __ykrt_control_point, 3i32, %1_1, %0_6, 0i64, %0_6, %0_7, %0_8, %1_1) [safepoint: 0i64, (%0_6, %0_7, %0_8, %1_1)]
    # simplecall.c:64: fprintf(stderr, "%d\n", i);
    br bb13
  bb13:
    call __yk_trace_basicblock(3i32, 13i32)
    %13_1: ptr = load @stderr
    %13_2: i32 = load %0_8
    %13_3: i32 = call fprintf(%13_1, @.str.2, %13_2)
    # simplecall.c:65: foo(i);
    br bb14
  bb14:
    call __yk_trace_basicblock(3i32, 14i32)
    %14_1: i32 = load %0_8
    # simplecall.c:45: if (i > 1) {
    %14_2: i1 = sgt %14_1, 1i32
    %14_3: ptr = load @stderr
    %14_4: ptr = select %14_2, @.str, @.str.1
    %14_5: i64 = call fwrite(%14_4, 4i64, 1i64, %14_3)
    # simplecall.c:66: res += 2;
    br bb15
  bb15:
    call __yk_trace_basicblock(3i32, 15i32)
    %15_1: i32 = load %0_7
    %15_2: i32 = add %15_1, 2i32
    *%0_7 = %15_2
    # simplecall.c:67: i--;
    %15_4: i32 = load %0_8
    %15_5: i32 = add %15_4, -1i32
    *%0_8 = %15_5
    # simplecall.c:62: while (i > 0) {
    %15_7: i1 = sgt %15_4, 1i32
    condbr %15_7, bb26, bb16 [safepoint: 3i64, (%0_6, %0_7, %0_8, %1_1, %15_5, %15_7)]
  bb16:
    # simplecall.c:69: fprintf(stderr, "%d\n", i);
    call __yk_trace_basicblock(3i32, 16i32)
    br bb17
  bb17:
    # simplecall.c:62: while (i > 0) {
    %17_0: i32 = phi bb10 -> %10_1, bb16 -> %15_5
    # simplecall.c:69: fprintf(stderr, "%d\n", i);
    call __yk_trace_basicblock(3i32, 17i32)
    %17_2: ptr = load @stderr
    %17_3: i32 = call fprintf(%17_2, @.str.2, %17_0)
    # simplecall.c:70: fprintf(stderr, "exit\n");
    br bb18
  bb18:
    call __yk_trace_basicblock(3i32, 18i32)
    %18_1: ptr = load @stderr
    %18_2: i64 = call fwrite(@.str.3, 5i64, 1i64, %18_1)
    # simplecall.c:71: NOOPT_VAL(res);
    br bb19
  bb19:
    call __yk_trace_basicblock(3i32, 19i32)
    %19_1: i32 = load %0_7
    # simplecall.c:72: yk_location_drop(loc);
    br bb20
  bb20:
    call __yk_trace_basicblock(3i32, 20i32)
    %20_1: i64 = load %0_6
    call yk_location_drop(%20_1)
    # simplecall.c:73: yk_mt_shutdown(mt);
    br bb21
  bb21:
    call __yk_trace_basicblock(3i32, 21i32)
    call yk_mt_shutdown(%1_1)
    # simplecall.c:75: }
    br bb22
  bb22:
    call __yk_trace_basicblock(3i32, 22i32)
    call llvm.lifetime.end.p0(4i64, %0_8)
    br bb23
  bb23:
    call __yk_trace_basicblock(3i32, 23i32)
    call llvm.lifetime.end.p0(4i64, %0_7)
    br bb24
  bb24:
    call __yk_trace_basicblock(3i32, 24i32)
    call llvm.lifetime.end.p0(8i64, %0_6)
    # simplecall.c:74: return (EXIT_SUCCESS);
    br bb25
  bb25:
    call __yk_trace_basicblock(3i32, 25i32)
    br bb28
  bb26:
    call __yk_trace_basicblock(3i32, 26i32)
    br bb12
  bb27:
    call __yk_trace_basicblock(3i32, 27i32)
    ret 0i32
  bb28:
    call __yk_trace_basicblock(3i32, 28i32)
    br bb27
}

func yk_mt_new(%arg0: ptr) -> ptr;

func yk_mt_hot_threshold_set(%arg0: ptr, %arg1: i32);

func llvm.lifetime.start.p0(%arg0: i64, %arg1: ptr);

func llvm.dbg.declare(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func yk_location_new() -> i64;

func yk_mt_control_point(%arg0: ptr, %arg1: ptr);

func fprintf(%arg0: ptr, %arg1: ptr, ...) -> i32;

func yk_location_drop(%arg0: i64);

func yk_mt_shutdown(%arg0: ptr);

func llvm.lifetime.end.p0(%arg0: i64, %arg1: ptr);

func malloc(%arg0: i64) -> ptr;

func __ykrt_control_point(%arg0: ptr, %arg1: ptr, %arg2: i64);

func llvm.experimental.patchpoint.void(%arg0: i64, %arg1: i32, %arg2: ptr, %arg3: i32, ...);

func llvm.experimental.stackmap(%arg0: i64, %arg1: i32, ...);

func __yk_trace_basicblock(%arg0: i32, %arg1: i32);

--- End aot ---
--- Begin jit-pre-opt ---
; compiled trace ID #0

func_decl fprintf (ptr, ptr, ...) -> i32
func_decl fwrite (ptr, i64, i64, ptr) -> i64
global_decl @stderr
global_decl @.str.2
global_decl @.str
global_decl @.str.1

entry:
    %0: ptr = param Direct(6, -40, 8)
    %1: ptr = param Register(14, 8, [])
    %2: ptr = param Register(12, 8, [])
    %3: ptr = param Register(3, 8, [])
    header_start [%0, %1, %2, %3]
    %5: ptr = lookup_global @stderr
    %6: ptr = load %5
    %7: i32 = load %2
    %8: ptr = lookup_global @.str.2
    %9: i32 = call @fprintf(%6, %8, %7)
    %10: i32 = load %2
    %11: i1 = sgt %10, 1i32
    %12: ptr = lookup_global @stderr
    %13: ptr = load %12
    %14: ptr = lookup_global @.str
    %15: ptr = lookup_global @.str.1
    %16: ptr = %11 ? %14 : %15
    %19: i64 = call @fwrite(%16, 4i64, 1i64, %13)
    %20: i32 = load %1
    %21: i32 = add %20, 2i32
    *%1 = %21
    %23: i32 = load %2
    %24: i32 = add %23, 4294967295i32
    *%2 = %24
    %26: i1 = sgt %23, 1i32
    guard true, %26, [3:%0_6: %0, 3:%0_7: %1, 3:%0_8: %2, 3:%1_1: %3, 3:%15_5: %24, 3:%15_7: 0i1] ; trace_gidx 0 safepoint_id 3
    header_end [%0, %1, %2, %3]
--- End jit-pre-opt ---
3
foo
yk-jit-event: enter-jit-code
2
foo
1
bar
yk-jit-event: deoptimise
0
exit
