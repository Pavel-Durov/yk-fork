---
description: SWT module clone
globs: *.rs, *.cpp, *.h, *.c, *.ir, *.txt, *.md
alwaysApply: false
---
# Context

In JIT tracing systems, the tracing mechanism plays a crucial role.
However, this mechanism introduces runtime overhead as the program
executes additional instructions for tracing. The primary concept in
JIT is that this overhead should be minimal when compared to the
execution of the optimised version of the compiled code, which does
not need the tracing functionality during runtime.

The concept of achieving an optimal balance between performance and
functionality is encapsulated in the idea of multi-version Intermediate
Representation (IR) functions. For each ykllvm program compiled for the
Software Tracing (SWT) framework, two distinct versions of the IR
functions will be generated:

1. **The Optimised Function**: This version encompasses all instructions
   necessary for tracing execution, including meta-instruction calls
   and additional instructions such as debugging and stack maps, which0
   are integral to the deoptimization mechanism.

2. **The Unoptimised Function**: This is a derivative of the original
   function and stripped of any non-essential instructions.
   Consequently, these functions exhibit minimal overhead in
   comparison to their original counterparts.

This versioning is achieved by introducing an LLVM pass called
ModuleClone.cpp to ykllvm and some minor adjustments to the existing
configurations.


## Multiple Control points

Incorporating the ModuleClone pass into the LLVM pass chain creates an
LLVM Module with two control points, one in each vesrion of the main
loop function. The general idea is to switch between these control
points based on the JIT state. If the JIT is not tracing, we will
execute the optimised functions; if it is tracing, we will executee
the original versions. This is achieved through assembly code written
in cp.rs that is main responsibility is to copy live variables before
the transition and then jump to control points accordingly.


## Control flow:

__ykrt_control_point in ykcapi/src/lib.rs is responsible for saving the state of various registers before transitioning control to the trace. It pushes the registers in the following order:
push rax
push rcx
push rbx
push rdi
push rsi
push r8
push r9
push r10
push r11
push r12
push r13
push r14
push r15

After pushing these registers, it calls __ykrt_control_point_real.

__ykrt_control_point_real calls control_point function in ykrt/src/mt.rs which depending on the JIT state will perform control point transition defined in ykrt/src/trace/swt/cp.rs and execute traces.

ykrt/src/trace/swt/cp.rs is responsible for restoring all the registers saved by __ykrt_control_point before JIT tracing starts, stops or traces being executed.



# Examples

## simplecall.c

Example of LLVM IR module with both Unoptimised and Optimised functions for simplecall.c test.

### simplecall.c source code

```cpp
```
### simplecall.c compiled IR module

```ir
# IR format version: 0
# Num funcs: 22
# Num consts: 38
# Num global decls: 6
# Num types: 24
global_decl @stderr
global_decl @.str
global_decl @.str.1
global_decl @shadowstack_0
global_decl @.str.2
global_decl @.str.3

func foo(%arg0: i32) {
  bb0:
    %0_0: i32 = arg(0)
    call __yk_trace_basicblock_dummy(0i32, 0i32)
    br bb1
  bb1:
    # simplecall.c:47: if (i > 1) {
    call __yk_trace_basicblock_dummy(0i32, 1i32)
    %1_1: i1 = sgt %0_0, 1i32
    %1_2: ptr = load @stderr
    %1_3: ptr = select %1_1, @.str, @.str.1
    %1_4: i64 = call fwrite(%1_3, 4i64, 1i64, %1_2)
    # simplecall.c:52: }
    br bb2
  bb2:
    call __yk_trace_basicblock_dummy(0i32, 2i32)
    br bb4
  bb3:
    call __yk_trace_basicblock_dummy(0i32, 3i32)
    ret
  bb4:
    call __yk_trace_basicblock_dummy(0i32, 4i32)
    br bb3
}

func llvm.dbg.value(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func fwrite(%arg0: ptr, %arg1: i64, %arg2: i64, %arg3: ptr) -> i64;

func main(%arg0: i32, %arg1: ptr) -> i32 {
  bb0:
    %0_0: i32 = arg(0)
    %0_1: ptr = arg(1)
    call __yk_trace_basicblock_dummy(3i32, 0i32)
    %0_3: ptr = call malloc(1000000i64)
    %0_4: ptr = ptr_add %0_3, 8
    *@shadowstack_0 = %0_4
    %0_6: ptr = alloca {0: i64}, 1, 8
    %0_7: ptr = ptr_add %0_3, 0
    %0_8: ptr = ptr_add %0_3, 4
    br bb1
  bb1:
    # simplecall.c:55: YkMT *mt = yk_mt_new(NULL);
    call __yk_trace_basicblock_dummy(3i32, 1i32)
    %1_1: ptr = call yk_mt_new(0x0)
    br bb2
  bb2:
    # simplecall.c:56: yk_mt_hot_threshold_set(mt, 0);
    call __yk_trace_basicblock_dummy(3i32, 2i32)
    call yk_mt_hot_threshold_set(%1_1, 0i32)
    # simplecall.c:57: YkLocation loc = yk_location_new();
    br bb3
  bb3:
    call __yk_trace_basicblock_dummy(3i32, 3i32)
    call llvm.lifetime.start.p0(8i64, %0_6)
    br bb4
  bb4:
    call __yk_trace_basicblock_dummy(3i32, 4i32)
    %4_1: i64 = call yk_location_new()
    br bb5
  bb5:
    call __yk_trace_basicblock_dummy(3i32, 5i32)
    *%0_6 = %4_1
    # simplecall.c:59: int res = 9998;
    call llvm.lifetime.start.p0(4i64, %0_7)
    br bb6
  bb6:
    call __yk_trace_basicblock_dummy(3i32, 6i32)
    *%0_7 = 9998i32
    # simplecall.c:60: int i = 4;
    call llvm.lifetime.start.p0(4i64, %0_8)
    br bb7
  bb7:
    call __yk_trace_basicblock_dummy(3i32, 7i32)
    *%0_8 = 4i32
    # simplecall.c:62: NOOPT_VAL(res);
    br bb8
  bb8:
    call __yk_trace_basicblock_dummy(3i32, 8i32)
    %8_1: i32 = load %0_7
    # simplecall.c:63: NOOPT_VAL(i);
    br bb9
  bb9:
    call __yk_trace_basicblock_dummy(3i32, 9i32)
    %9_1: i32 = load %0_8
    # simplecall.c:64: while (i > 0) {
    br bb10
  bb10:
    call __yk_trace_basicblock_dummy(3i32, 10i32)
    %10_1: i32 = load %0_8
    %10_2: i1 = sgt %10_1, 0i32
    condbr %10_2, bb11, bb17 [safepoint: 3i64, (%0_6, %0_7, %0_8, %1_1, %10_1, %10_2)]
  bb11:
    call __yk_trace_basicblock_dummy(3i32, 11i32)
    br bb12
  bb12:
    # simplecall.c:65: yk_mt_control_point(mt, &loc);
    call __yk_trace_basicblock_dummy(3i32, 12i32)
    call llvm.experimental.patchpoint.void(0i64, 13i32, __ykrt_control_point, 3i32, %1_1, %0_6, 0i64, %0_6, %0_7, %0_8, %1_1) [safepoint: 0i64, (%0_6, %0_7, %0_8, %1_1)]
    # simplecall.c:66: fprintf(stderr, "%d\n", i);
    br bb13
  bb13:
    call __yk_trace_basicblock_dummy(3i32, 13i32)
    %13_1: ptr = load @stderr
    %13_2: i32 = load %0_8
    %13_3: i32 = call fprintf(%13_1, @.str.2, %13_2)
    # simplecall.c:67: foo(i);
    br bb14
  bb14:
    call __yk_trace_basicblock_dummy(3i32, 14i32)
    %14_1: i32 = load %0_8
    # simplecall.c:47: if (i > 1) {
    %14_2: i1 = sgt %14_1, 1i32
    %14_3: ptr = load @stderr
    %14_4: ptr = select %14_2, @.str, @.str.1
    %14_5: i64 = call fwrite(%14_4, 4i64, 1i64, %14_3)
    # simplecall.c:68: res += 2;
    br bb15
  bb15:
    call __yk_trace_basicblock_dummy(3i32, 15i32)
    %15_1: i32 = load %0_7
    %15_2: i32 = add %15_1, 2i32
    *%0_7 = %15_2
    # simplecall.c:69: i--;
    %15_4: i32 = load %0_8
    %15_5: i32 = add %15_4, -1i32
    *%0_8 = %15_5
    # simplecall.c:64: while (i > 0) {
    %15_7: i1 = sgt %15_4, 1i32
    condbr %15_7, bb26, bb16 [safepoint: 4i64, (%0_6, %0_7, %0_8, %1_1, %15_5, %15_7)]
  bb16:
    # simplecall.c:71: fprintf(stderr, "%d\n", i);
    call __yk_trace_basicblock_dummy(3i32, 16i32)
    br bb17
  bb17:
    # simplecall.c:64: while (i > 0) {
    %17_0: i32 = phi bb10 -> %10_1, bb16 -> %15_5
    # simplecall.c:71: fprintf(stderr, "%d\n", i);
    call __yk_trace_basicblock_dummy(3i32, 17i32)
    %17_2: ptr = load @stderr
    %17_3: i32 = call fprintf(%17_2, @.str.2, %17_0)
    # simplecall.c:72: fprintf(stderr, "exit\n");
    br bb18
  bb18:
    call __yk_trace_basicblock_dummy(3i32, 18i32)
    %18_1: ptr = load @stderr
    %18_2: i64 = call fwrite(@.str.3, 5i64, 1i64, %18_1)
    # simplecall.c:73: NOOPT_VAL(res);
    br bb19
  bb19:
    call __yk_trace_basicblock_dummy(3i32, 19i32)
    %19_1: i32 = load %0_7
    # simplecall.c:74: yk_location_drop(loc);
    br bb20
  bb20:
    call __yk_trace_basicblock_dummy(3i32, 20i32)
    %20_1: i64 = load %0_6
    call yk_location_drop(%20_1)
    # simplecall.c:75: yk_mt_shutdown(mt);
    br bb21
  bb21:
    call __yk_trace_basicblock_dummy(3i32, 21i32)
    call yk_mt_shutdown(%1_1)
    # simplecall.c:77: }
    br bb22
  bb22:
    call __yk_trace_basicblock_dummy(3i32, 22i32)
    call llvm.lifetime.end.p0(4i64, %0_8)
    br bb23
  bb23:
    call __yk_trace_basicblock_dummy(3i32, 23i32)
    call llvm.lifetime.end.p0(4i64, %0_7)
    br bb24
  bb24:
    call __yk_trace_basicblock_dummy(3i32, 24i32)
    call llvm.lifetime.end.p0(8i64, %0_6)
    # simplecall.c:76: return (EXIT_SUCCESS);
    br bb25
  bb25:
    call __yk_trace_basicblock_dummy(3i32, 25i32)
    br bb28
  bb26:
    call __yk_trace_basicblock_dummy(3i32, 26i32)
    br bb12
  bb27:
    call __yk_trace_basicblock_dummy(3i32, 27i32)
    ret 0i32
  bb28:
    call __yk_trace_basicblock_dummy(3i32, 28i32)
    br bb27
}

func yk_mt_new(%arg0: ptr) -> ptr;

func yk_mt_hot_threshold_set(%arg0: ptr, %arg1: i32);

func llvm.lifetime.start.p0(%arg0: i64, %arg1: ptr);

func llvm.dbg.declare(%arg0: ?ty<metadata>, %arg1: ?ty<metadata>, %arg2: ?ty<metadata>);

func yk_location_new() -> i64;

func yk_mt_control_point(%arg0: ptr, %arg1: ptr);

func fprintf(%arg0: ptr, %arg1: ptr, ...) -> i32;

func yk_location_drop(%arg0: i64);

func yk_mt_shutdown(%arg0: ptr);

func llvm.lifetime.end.p0(%arg0: i64, %arg1: ptr);

func __yk_unopt_foo(%arg0: i32) {
  bb0:
    %0_0: i32 = arg(0)
    call __yk_trace_basicblock(14i32, 0i32)
    br bb1
  bb1:
    # simplecall.c:47: if (i > 1) {
    call __yk_trace_basicblock(14i32, 1i32)
    %1_1: i1 = sgt %0_0, 1i32
    %1_2: ptr = load @stderr
    %1_3: ptr = select %1_1, @.str, @.str.1
    %1_4: i64 = call fwrite(%1_3, 4i64, 1i64, %1_2)
    # simplecall.c:52: }
    br bb2
  bb2:
    call __yk_trace_basicblock(14i32, 2i32)
    br bb4
  bb3:
    call __yk_trace_basicblock(14i32, 3i32)
    ret
  bb4:
    call __yk_trace_basicblock(14i32, 4i32)
    br bb3
}

func __yk_unopt_main(%arg0: i32, %arg1: ptr) -> i32 {
  bb0:
    %0_0: i32 = arg(0)
    %0_1: ptr = arg(1)
    call __yk_trace_basicblock(15i32, 0i32)
    %0_3: ptr = load @shadowstack_0
    %0_4: ptr = alloca {0: i64}, 1, 8
    %0_5: ptr = ptr_add %0_3, 0
    %0_6: ptr = ptr_add %0_3, 4
    br bb1
  bb1:
    # simplecall.c:55: YkMT *mt = yk_mt_new(NULL);
    call __yk_trace_basicblock(15i32, 1i32)
    %1_1: ptr = call yk_mt_new(0x0)
    br bb2
  bb2:
    # simplecall.c:56: yk_mt_hot_threshold_set(mt, 0);
    call __yk_trace_basicblock(15i32, 2i32)
    call yk_mt_hot_threshold_set(%1_1, 0i32)
    # simplecall.c:57: YkLocation loc = yk_location_new();
    br bb3
  bb3:
    call __yk_trace_basicblock(15i32, 3i32)
    call llvm.lifetime.start.p0(8i64, %0_4)
    br bb4
  bb4:
    call __yk_trace_basicblock(15i32, 4i32)
    %4_1: i64 = call yk_location_new()
    br bb5
  bb5:
    call __yk_trace_basicblock(15i32, 5i32)
    *%0_4 = %4_1
    # simplecall.c:59: int res = 9998;
    call llvm.lifetime.start.p0(4i64, %0_5)
    br bb6
  bb6:
    call __yk_trace_basicblock(15i32, 6i32)
    *%0_5 = 9998i32
    # simplecall.c:60: int i = 4;
    call llvm.lifetime.start.p0(4i64, %0_6)
    br bb7
  bb7:
    call __yk_trace_basicblock(15i32, 7i32)
    *%0_6 = 4i32
    # simplecall.c:62: NOOPT_VAL(res);
    br bb8
  bb8:
    call __yk_trace_basicblock(15i32, 8i32)
    %8_1: i32 = load %0_5
    # simplecall.c:63: NOOPT_VAL(i);
    br bb9
  bb9:
    call __yk_trace_basicblock(15i32, 9i32)
    %9_1: i32 = load %0_6
    # simplecall.c:64: while (i > 0) {
    br bb10
  bb10:
    call __yk_trace_basicblock(15i32, 10i32)
    %10_1: i32 = load %0_6
    %10_2: i1 = sgt %10_1, 0i32
    condbr %10_2, bb11, bb17 [safepoint: 2i64, (%0_4, %0_5, %0_6, %1_1, %10_1, %10_2)]
  bb11:
    call __yk_trace_basicblock(15i32, 11i32)
    br bb12
  bb12:
    # simplecall.c:65: yk_mt_control_point(mt, &loc);
    call __yk_trace_basicblock(15i32, 12i32)
    call llvm.experimental.patchpoint.void(1i64, 13i32, __ykrt_control_point, 3i32, %1_1, %0_4, 1i64, %0_4, %0_5, %0_6, %1_1) [safepoint: 1i64, (%0_4, %0_5, %0_6, %1_1)]
    # simplecall.c:66: fprintf(stderr, "%d\n", i);
    br bb13
  bb13:
    call __yk_trace_basicblock(15i32, 13i32)
    %13_1: ptr = load @stderr
    %13_2: i32 = load %0_6
    %13_3: i32 = call fprintf(%13_1, @.str.2, %13_2)
    # simplecall.c:67: foo(i);
    br bb14
  bb14:
    call __yk_trace_basicblock(15i32, 14i32)
    %14_1: i32 = load %0_6
    # simplecall.c:47: if (i > 1) {
    %14_2: i1 = sgt %14_1, 1i32
    %14_3: ptr = load @stderr
    %14_4: ptr = select %14_2, @.str, @.str.1
    %14_5: i64 = call fwrite(%14_4, 4i64, 1i64, %14_3)
    # simplecall.c:68: res += 2;
    br bb15
  bb15:
    call __yk_trace_basicblock(15i32, 15i32)
    %15_1: i32 = load %0_5
    %15_2: i32 = add %15_1, 2i32
    *%0_5 = %15_2
    # simplecall.c:69: i--;
    %15_4: i32 = load %0_6
    %15_5: i32 = add %15_4, -1i32
    *%0_6 = %15_5
    # simplecall.c:64: while (i > 0) {
    %15_7: i1 = sgt %15_4, 1i32
    condbr %15_7, bb26, bb16 [safepoint: 5i64, (%0_4, %0_5, %0_6, %1_1, %15_5, %15_7)]
  bb16:
    # simplecall.c:71: fprintf(stderr, "%d\n", i);
    call __yk_trace_basicblock(15i32, 16i32)
    br bb17
  bb17:
    # simplecall.c:64: while (i > 0) {
    %17_0: i32 = phi bb10 -> %10_1, bb16 -> %15_5
    # simplecall.c:71: fprintf(stderr, "%d\n", i);
    call __yk_trace_basicblock(15i32, 17i32)
    %17_2: ptr = load @stderr
    %17_3: i32 = call fprintf(%17_2, @.str.2, %17_0)
    # simplecall.c:72: fprintf(stderr, "exit\n");
    br bb18
  bb18:
    call __yk_trace_basicblock(15i32, 18i32)
    %18_1: ptr = load @stderr
    %18_2: i64 = call fwrite(@.str.3, 5i64, 1i64, %18_1)
    # simplecall.c:73: NOOPT_VAL(res);
    br bb19
  bb19:
    call __yk_trace_basicblock(15i32, 19i32)
    %19_1: i32 = load %0_5
    # simplecall.c:74: yk_location_drop(loc);
    br bb20
  bb20:
    call __yk_trace_basicblock(15i32, 20i32)
    %20_1: i64 = load %0_4
    call yk_location_drop(%20_1)
    # simplecall.c:75: yk_mt_shutdown(mt);
    br bb21
  bb21:
    call __yk_trace_basicblock(15i32, 21i32)
    call yk_mt_shutdown(%1_1)
    # simplecall.c:77: }
    br bb22
  bb22:
    call __yk_trace_basicblock(15i32, 22i32)
    call llvm.lifetime.end.p0(4i64, %0_6)
    br bb23
  bb23:
    call __yk_trace_basicblock(15i32, 23i32)
    call llvm.lifetime.end.p0(4i64, %0_5)
    br bb24
  bb24:
    call __yk_trace_basicblock(15i32, 24i32)
    call llvm.lifetime.end.p0(8i64, %0_4)
    # simplecall.c:76: return (EXIT_SUCCESS);
    br bb25
  bb25:
    call __yk_trace_basicblock(15i32, 25i32)
    br bb28
  bb26:
    call __yk_trace_basicblock(15i32, 26i32)
    br bb12
  bb27:
    call __yk_trace_basicblock(15i32, 27i32)
    ret 0i32
  bb28:
    call __yk_trace_basicblock(15i32, 28i32)
    br bb27
}

func malloc(%arg0: i64) -> ptr;

func __ykrt_control_point(%arg0: ptr, %arg1: ptr, %arg2: i64);

func llvm.experimental.patchpoint.void(%arg0: i64, %arg1: i32, %arg2: ptr, %arg3: i32, ...);

func llvm.experimental.stackmap(%arg0: i64, %arg1: i32, ...);

func __yk_trace_basicblock(%arg0: i32, %arg1: i32);

func __yk_trace_basicblock_dummy(%arg0: i32, %arg1: i32);
```

### simplecall.c compiled trace

```
; compiled trace ID #0

func_decl fprintf (ptr, ptr, ...) -> i32
func_decl fwrite (ptr, i64, i64, ptr) -> i64
global_decl @stderr
global_decl @.str.2
global_decl @.str
global_decl @.str.1

entry:
    %0: ptr = param Direct(6, -40, 8)
    %1: ptr = param Register(15, 8, [])
    %2: ptr = param Register(12, 8, [])
    %3: ptr = param Register(3, 8, [])
    header_start [%0, %1, %2, %3]
    %5: ptr = lookup_global @stderr
    %6: ptr = load %5
    %7: i32 = load %2
    %8: ptr = lookup_global @.str.2
    %9: i32 = call @fprintf(%6, %8, %7)
    %10: i32 = load %2
    %11: i1 = sgt %10, 1i32
    %12: ptr = lookup_global @stderr
    %13: ptr = load %12
    %14: ptr = lookup_global @.str
    %15: ptr = lookup_global @.str.1
    %16: ptr = %11 ? %14 : %15
    %19: i64 = call @fwrite(%16, 4i64, 1i64, %13)
    %20: i32 = load %1
    %21: i32 = add %20, 2i32
    *%1 = %21
    %23: i32 = load %2
    %24: i32 = add %23, 4294967295i32
    *%2 = %24
    %26: i1 = sgt %23, 1i32
    guard true, %26, [15:%0_4: %0, 15:%0_5: %1, 15:%0_6: %2, 15:%1_1: %3, 15:%15_5: %24, 15:%15_7: 0i1] ; trace_gidx 0 safepoint_id 5
    header_end [%0, %1, %2, %3]
```

# Task

You are a specialist compiler engineer dealing with the Yk compiler which
is a meta-tracing framework written on top of LLVM. The main interpreter
compiled with Yk is YkLua - Lua interpreter with Yk integration.

Please review user questions and referenced files, and respond with
suggested code changes. Before replying, familiarise your self with
the control point transition in cp.rs and contorl point transition in
ykrt/src/mt.rs.


# Output

1. Respond in british academic english.
2. Try to be concise, try to give responses that are 500 words or less.
3. If you don't know the answer, say so. Don't make stuff up.
4. Be familiar with the codebase and the programming languages, it is written in C/C++ and Rust.
5. With code examples, provide the diff instead of the whole file.
6. Provide brief explanation of the changes and the reasoning.


# Debug output

## Register live varible
Register(15, 8, [3, -50]) - Register:r15, value size: 6, additional locations: register r3, rbp-50

## Indirect Register live varible
Indirect(6, -80, 8) - Register rbp, location: rbp-80, value size: 8

# Source code

- JIT decision of tracing, stop-tracing, trace compilation and trace execution is implemented in [mt.rs](mdc:ykrt/src/mt.rs)
- SWT control point transition between unopt and opt functions is implemented in [cp.rs](mdc:ykrt/src/trace/swt/cp.rs)
- Live varibles copy for SWT si implemented in [live_vars.rs](mdc:ykrt/src/trace/swt/live_vars.rs)


# Changes

Please modify only @cp.rs and @live_vars.rs when debugging control point transition with SWT.

# Tests

- All failing tests with SWT are marked with `// ignore-if: test $SWT_SKIP_FAILING_TEST=true`
- To run all passing test with SWT, run this command: `SWT_SKIP_FAILING_TEST=true YKB_TRACER=swt cargo test`
- To run a test with verbose output use these env vars: `CP_PRINT_MACHINE_CODE=1 CP_VERBOSE_ASM=1 CP_VERBOSE=1`
  


